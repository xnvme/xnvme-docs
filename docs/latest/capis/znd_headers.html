

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>znd: headers &mdash; xNVMe 0.0.18 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="xnvmec" href="xnvmec.html" />
    <link rel="prev" title="znd" href="znd.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> xNVMe
          

          
          </a>

          
            
            
              <div class="version">
                0.0.18
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../quick_start/index.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Tools</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">C APIs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="xnvme.html">xnvme</a></li>
<li class="toctree-l2"><a class="reference internal" href="xnvme_headers.html">xnvme: headers</a></li>
<li class="toctree-l2"><a class="reference internal" href="lblk.html">lblk</a></li>
<li class="toctree-l2"><a class="reference internal" href="lblk_headers.html">lblk: headers</a></li>
<li class="toctree-l2"><a class="reference internal" href="znd.html">znd</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">znd: headers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#libznd-h">libznd.h</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="xnvmec.html">xnvmec</a></li>
<li class="toctree-l2"><a class="reference internal" href="xnvmec_headers.html">xnvmec: headers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../examples/index.html">C APIs: Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../backends/index.html">Backends</a></li>
<li class="toctree-l1"><a class="reference internal" href="../building/index.html">Building xNVMe from source</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">xNVMe</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">C APIs</a> &raquo;</li>
        
      <li>znd: headers</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/capis/znd_headers.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="znd-headers">
<span id="sec-c-apis-znd-headers"></span><h1>znd: headers<a class="headerlink" href="#znd-headers" title="Permalink to this headline">¶</a></h1>
<div class="section" id="libznd-h">
<h2>libznd.h<a class="headerlink" href="#libznd-h" title="Permalink to this headline">¶</a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * The User space library for Zoned Namespaces based on xNVMe, the</span>
<span class="cm"> * Cross-platform libraries and tools for NVMe devices</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) Simon A. F. Lund &lt;simon.lund@samsung.com&gt;</span>
<span class="cm"> * SPDX-License-Identifier: Apache-2.0</span>
<span class="cm"> *</span>
<span class="cm"> * @headerfile libznd.h</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __LIBZND_H</span>
<span class="cp">#define __LIBZND_H</span>

<span class="cp">#ifdef __cplusplus</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>
<span class="cp">#endif</span>

<span class="cp">#include</span> <span class="cpf">&lt;libxnvme.h&gt;</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * Zoned Command Set opcodes</span>
<span class="cm"> *</span>
<span class="cm"> * @see Specification Section 6, figure ZONEDOPCODES</span>
<span class="cm"> *</span>
<span class="cm"> * @struct znd_cmd_opc</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">znd_cmd_opc</span> <span class="p">{</span>
	<span class="n">ZND_CMD_OPC_MGMT_SEND</span>	<span class="o">=</span> <span class="mh">0x79</span><span class="p">,</span>	<span class="c1">///&lt; ZND_CMD_OPC_MGMT_SEND</span>
	<span class="n">ZND_CMD_OPC_MGMT_RECV</span>	<span class="o">=</span> <span class="mh">0x7A</span><span class="p">,</span>	<span class="c1">///&lt; ZND_CMD_OPC_MGMT_RECV</span>
	<span class="n">ZND_CMD_OPC_APPEND</span>	<span class="o">=</span> <span class="mh">0x7D</span><span class="p">,</span>	<span class="c1">///&lt; ZND_CMD_OPC_APPEND</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Log identifiers for Zoned Namespaces</span>
<span class="cm"> *</span>
<span class="cm"> * @enum znd_cmd_log_lid</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">znd_cmd_log_lid</span> <span class="p">{</span>
	<span class="n">ZND_CMD_LOG_CHANGES</span> <span class="o">=</span> <span class="mh">0xBF</span><span class="p">,</span>	<span class="c1">///&lt; ZND_CMD_LOG_CHANGES</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * NVMe Command Accessor for command with opcode ZND_CMD_OPC_MGMT_SEND</span>
<span class="cm"> *</span>
<span class="cm"> * @struct znd_cmd_mgmt_send</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">znd_cmd_mgmt_send</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">cdw00_09</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>		<span class="c1">///&lt; Command dword 0 to 9</span>

	<span class="cm">/* cdw 10-11 */</span>
	<span class="kt">uint64_t</span> <span class="n">slba</span><span class="p">;</span>			<span class="c1">///&lt; Start LBA</span>

	<span class="kt">uint32_t</span> <span class="n">cdw12</span><span class="p">;</span>

	<span class="cm">/* cdw 13 */</span>
	<span class="kt">uint32_t</span> <span class="nl">zsa</span>		<span class="p">:</span> <span class="mi">8</span><span class="p">;</span>	<span class="c1">///&lt; Zone Send Action</span>
	<span class="kt">uint32_t</span> <span class="nl">zsasf</span>		<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">///&lt; Select All</span>
	<span class="kt">uint32_t</span> <span class="nl">rsvd</span>		<span class="p">:</span> <span class="mi">23</span><span class="p">;</span>

	<span class="kt">uint32_t</span> <span class="n">cdw14_15</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>		<span class="c1">///&lt; Command dword 14 to 15</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">znd_cmd_mgmt_send</span><span class="p">)</span> <span class="o">==</span> <span class="mi">64</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * NVMe Command Accessor for command with opcode ZND_CMD_OPC_MGMT_RECV</span>
<span class="cm"> *</span>
<span class="cm"> * @struct znd_cmd_mgmt_recv</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">znd_cmd_mgmt_recv</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">cdw00_09</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>	<span class="c1">///&lt; Command dword 0 to 9</span>

	<span class="cm">/* cdw 10-11 */</span>
	<span class="kt">uint64_t</span> <span class="n">slba</span><span class="p">;</span>			<span class="c1">///&lt; Start LBA</span>

	<span class="cm">/* cdw 12 */</span>
	<span class="kt">uint32_t</span> <span class="n">ndwords</span><span class="p">;</span>	<span class="c1">///&lt; Number of dwords in data-payload</span>

	<span class="cm">/* cdw 13 */</span>
	<span class="kt">uint32_t</span> <span class="nl">zra</span>		<span class="p">:</span> <span class="mi">8</span><span class="p">;</span>	<span class="c1">///&lt; Zone Receive Action</span>
	<span class="kt">uint32_t</span> <span class="nl">zrasf</span>		<span class="p">:</span> <span class="mi">8</span><span class="p">;</span>	<span class="c1">///&lt; Zone Receive Action Specific Field</span>
	<span class="kt">uint32_t</span> <span class="nl">partial</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">///&lt; Partial</span>

	<span class="kt">uint32_t</span> <span class="nl">rsvd</span>		<span class="p">:</span> <span class="mi">15</span><span class="p">;</span>

	<span class="cm">/* cdw 14-15 */</span>
	<span class="kt">uint64_t</span> <span class="n">addrs_dst</span><span class="p">;</span>		<span class="c1">///&lt; destination addresses</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">znd_cmd_mgmt_recv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">64</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * NVMe Command Accessor for command with opcode ZND_CMD_OPC_APPEND</span>
<span class="cm"> *</span>
<span class="cm"> * @struct znd_cmd_append</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">znd_cmd_append</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">cdw00_09</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>	<span class="c1">///&lt; Command dword 0 to 9</span>

	<span class="kt">uint64_t</span> <span class="n">zslba</span><span class="p">;</span>		<span class="c1">///&lt; SLBA: Start Logical Block Address</span>

	<span class="kt">uint32_t</span> <span class="nl">nlb</span>	<span class="p">:</span> <span class="mi">16</span><span class="p">;</span>	<span class="c1">///&lt; NLB: Number of logical blocks</span>
	<span class="kt">uint32_t</span> <span class="nl">rsvd</span>	<span class="p">:</span>  <span class="mi">4</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="nl">dtype</span>	<span class="p">:</span>  <span class="mi">4</span><span class="p">;</span>	<span class="c1">///&lt; DT: Directive Type</span>
	<span class="kt">uint32_t</span> <span class="nl">prinfo</span>	<span class="p">:</span>  <span class="mi">4</span><span class="p">;</span>	<span class="c1">///&lt; PI: Protection Information Field</span>
	<span class="kt">uint32_t</span> <span class="nl">rsvd2</span>	<span class="p">:</span>  <span class="mi">2</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="nl">fua</span>	<span class="p">:</span>  <span class="mi">1</span><span class="p">;</span>	<span class="c1">///&lt; FUA: Force unit access</span>
	<span class="kt">uint32_t</span> <span class="nl">lr</span>	<span class="p">:</span>  <span class="mi">1</span><span class="p">;</span>	<span class="c1">///&lt; LR: Limited retry</span>

	<span class="kt">uint32_t</span> <span class="n">cdw13_15</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>	<span class="c1">///&lt; Command dword 13 to 15</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">znd_cmd_append</span><span class="p">)</span> <span class="o">==</span> <span class="mi">64</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * NVMe Command Accessors for the Zoned Command Set</span>
<span class="cm"> *</span>
<span class="cm"> * @struct znd_cmd</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">znd_cmd</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">xnvme_spec_cmd</span> <span class="n">base</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">xnvme_spec_cmd_common</span> <span class="n">common</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">znd_cmd_mgmt_send</span> <span class="n">mgmt_send</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">znd_cmd_mgmt_recv</span> <span class="n">mgmt_recv</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">znd_cmd_append</span> <span class="n">append</span><span class="p">;</span>
		<span class="kt">uint32_t</span> <span class="n">cdw</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="p">};</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">znd_cmd</span><span class="p">)</span> <span class="o">==</span> <span class="mi">64</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * Command-set specific status codes related to Zoned Namespaces</span>
<span class="cm"> *</span>
<span class="cm"> * @see Specification Section 4.1.1.1.1, figures GENERICSTATUSCODES and</span>
<span class="cm"> * STATUSCODES</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">znd_status_code</span> <span class="p">{</span>
	<span class="c1">// Namespace Management</span>
	<span class="n">ZND_SC_INVALID_FORMAT</span>	<span class="o">=</span> <span class="mh">0x7F</span><span class="p">,</span>	<span class="c1">///&lt; ZND_SC_INVALID_FORMAT</span>

	<span class="c1">/// Zoned Command Set</span>
	<span class="n">ZND_SC_BOUNDARY_ERROR</span>	<span class="o">=</span> <span class="mh">0xB8</span><span class="p">,</span>	<span class="c1">///&lt; ZND_SC_BOUNDARY_ERROR</span>
	<span class="n">ZND_SC_IS_FULL</span>		<span class="o">=</span> <span class="mh">0xB9</span><span class="p">,</span>	<span class="c1">///&lt; ZND_SC_IS_FULL</span>
	<span class="n">ZND_SC_IS_READONLY</span>	<span class="o">=</span> <span class="mh">0xBA</span><span class="p">,</span>	<span class="c1">///&lt; ZND_SC_IS_READONLY</span>
	<span class="n">ZND_SC_IS_OFFLINE</span>	<span class="o">=</span> <span class="mh">0xBB</span><span class="p">,</span>	<span class="c1">///&lt; ZND_SC_IS_OFFLINE</span>
	<span class="n">ZND_SC_INVALID_WRITE</span>	<span class="o">=</span> <span class="mh">0xBC</span><span class="p">,</span>	<span class="c1">///&lt; ZND_SC_INVALID_WRITE</span>
	<span class="n">ZND_SC_TOO_MANY_ACTIVE</span>	<span class="o">=</span> <span class="mh">0xBD</span><span class="p">,</span>	<span class="c1">///&lt; ZND_SC_TOO_MANY_ACTIVE</span>
	<span class="n">ZND_SC_TOO_MANY_OPEN</span>	<span class="o">=</span> <span class="mh">0xBE</span><span class="p">,</span>	<span class="c1">///&lt; ZND_SC_TOO_MANY_OPEN</span>
	<span class="n">ZND_SC_INVALID_TRANS</span>	<span class="o">=</span> <span class="mh">0xBF</span><span class="p">,</span>	<span class="c1">///&lt; ZND_SC_INVALID_TRANS</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Produces a string representation of the given ::znd_status_code</span>
<span class="cm"> *</span>
<span class="cm"> * @param sc the enum value to produce a string representation of</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, a string representation is returned. On error, the string</span>
<span class="cm"> * &quot;ZND_SC_ENOSYS&quot; is returned.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span>
<span class="nf">znd_status_code_str</span><span class="p">(</span><span class="k">enum</span> <span class="n">znd_status_code</span> <span class="n">sc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * This is not defined in any spec... it would just seem sane if it was...</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">znd_send_action_sf</span> <span class="p">{</span>
	<span class="n">ZND_SEND_SF_SALL</span>	<span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>		<span class="c1">///&lt; ZND_SEND_SF_SALL</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Produces a string representation of the given ::znd_send_action_sf</span>
<span class="cm"> *</span>
<span class="cm"> * @param sf The send action specific field value to produce a string</span>
<span class="cm"> * representation of</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, a string representation is returned. On error, the string</span>
<span class="cm"> * &quot;ZND_SEND_SF_ENOSYS&quot; is returned.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span>
<span class="nf">znd_send_action_sf_str</span><span class="p">(</span><span class="k">enum</span> <span class="n">znd_send_action_sf</span> <span class="n">sf</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Actions for the Zone Management Send command</span>
<span class="cm"> *</span>
<span class="cm"> * @see Specification Section 6.1, figure TBDZMDW13</span>
<span class="cm"> *</span>
<span class="cm"> * @enum znd_send_action</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">znd_send_action</span> <span class="p">{</span>
	<span class="n">ZND_SEND_CLOSE</span>		<span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>	<span class="c1">///&lt; ZND_SEND_CLOSE</span>
	<span class="n">ZND_SEND_FINISH</span>		<span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>	<span class="c1">///&lt; ZND_SEND_FINISH</span>
	<span class="n">ZND_SEND_OPEN</span>		<span class="o">=</span> <span class="mh">0x3</span><span class="p">,</span>	<span class="c1">///&lt; ZND_SEND_OPEN</span>
	<span class="n">ZND_SEND_RESET</span>		<span class="o">=</span> <span class="mh">0x4</span><span class="p">,</span>	<span class="c1">///&lt; ZND_SEND_RESET</span>
	<span class="n">ZND_SEND_OFFLINE</span>	<span class="o">=</span> <span class="mh">0x5</span><span class="p">,</span>	<span class="c1">///&lt; ZND_SEND_OFFLINE</span>
	<span class="n">ZND_SEND_DESCRIPTOR</span>	<span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>	<span class="c1">///&lt; ZND_SEND_DESCRIPTOR</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Produces a string representation of the given ::znd_send_action</span>
<span class="cm"> *</span>
<span class="cm"> * @param action The action to produce a string representation of</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, a string representation is returned. On error, the string</span>
<span class="cm"> * &quot;ZND_SEND_ENOSYS&quot; is returned.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span>
<span class="nf">znd_send_action_str</span><span class="p">(</span><span class="k">enum</span> <span class="n">znd_send_action</span> <span class="n">action</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Zone Receive Action (::znd_send_action) specific field values</span>
<span class="cm"> *</span>
<span class="cm"> * @see Specification Section 6.2, figure TBDZMRDW13</span>
<span class="cm"> *</span>
<span class="cm"> * @enum znd_recv_action_sf</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">znd_recv_action_sf</span> <span class="p">{</span>
	<span class="n">ZND_RECV_SF_ALL</span>		<span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>	<span class="c1">///&lt; ZND_RECV_SF_ALL</span>
	<span class="n">ZND_RECV_SF_EMPTY</span>	<span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>	<span class="c1">///&lt; ZND_RECV_SF_EMPTY</span>
	<span class="n">ZND_RECV_SF_IOPEN</span>	<span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>	<span class="c1">///&lt; ZND_RECV_SF_IOPEN</span>
	<span class="n">ZND_RECV_SF_EOPEN</span>	<span class="o">=</span> <span class="mh">0x3</span><span class="p">,</span>	<span class="c1">///&lt; ZND_RECV_SF_EOPEN</span>
	<span class="n">ZND_RECV_SF_CLOSED</span>	<span class="o">=</span> <span class="mh">0x4</span><span class="p">,</span>	<span class="c1">///&lt; ZND_RECV_SF_CLOSED</span>
	<span class="n">ZND_RECV_SF_FULL</span>	<span class="o">=</span> <span class="mh">0x5</span><span class="p">,</span>	<span class="c1">///&lt; ZND_RECV_SF_FULL</span>
	<span class="n">ZND_RECV_SF_RONLY</span>	<span class="o">=</span> <span class="mh">0x6</span><span class="p">,</span>	<span class="c1">///&lt; ZND_RECV_SF_RONLY</span>
	<span class="n">ZND_RECV_SF_OFFLINE</span>	<span class="o">=</span> <span class="mh">0x7</span><span class="p">,</span>	<span class="c1">///&lt; ZND_RECV_SF_OFFLINE</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Produces a string representation of the given ::znd_recv_action_sf</span>
<span class="cm"> *</span>
<span class="cm"> * @param sf The send action specific field value to produce a string</span>
<span class="cm"> * representation of</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, a string representation is returned. On error, the string</span>
<span class="cm"> * &quot;ZND_RECV_SF_ENOSYS&quot; is returned.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span>
<span class="nf">znd_recv_action_sf_str</span><span class="p">(</span><span class="k">enum</span> <span class="n">znd_recv_action_sf</span> <span class="n">sf</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Zoned Receive Action</span>
<span class="cm"> *</span>
<span class="cm"> * @see Specification Section 6.2, figure TBDZMRDW13</span>
<span class="cm"> * @enum znd_recv_action</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">znd_recv_action</span> <span class="p">{</span>
	<span class="n">ZND_RECV_REPORT</span>		<span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>	<span class="c1">///&lt; ZND_RECV_REPORT</span>
	<span class="n">ZND_RECV_EREPORT</span>	<span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>	<span class="c1">///&lt; ZND_RECV_EREPORT</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Produces a string representation of the given ::znd_recv_action</span>
<span class="cm"> *</span>
<span class="cm"> * @param action The receive action to produce a string representation of</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, a string representation is returned. On error, the string</span>
<span class="cm"> * &quot;ZND_RECV_ENOSYS&quot; is returned.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span>
<span class="nf">znd_recv_action_str</span><span class="p">(</span><span class="k">enum</span> <span class="n">znd_recv_action</span> <span class="n">action</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Zone Type</span>
<span class="cm"> *</span>
<span class="cm"> * @see Specification Section 6.2.2.3, figure TBDZMRD</span>
<span class="cm"> * @enum znd_type</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">znd_type</span> <span class="p">{</span>
	<span class="n">ZND_TYPE_SEQWR</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>	<span class="c1">///&lt; ZND_TYPE_SEQWR</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Produces a string representation of the given ::znd_type</span>
<span class="cm"> *</span>
<span class="cm"> * @param zt the ::znd_type to produce a string representation of</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, a string representation is returned. On error, the string</span>
<span class="cm"> * &quot;ZND_TYPE_ENOSYS&quot; is returned.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span>
<span class="nf">znd_type_str</span><span class="p">(</span><span class="k">enum</span> <span class="n">znd_type</span> <span class="n">zt</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Zone State as reported by Zone Management Receive</span>
<span class="cm"> *</span>
<span class="cm"> * @see Specification Section 6.2.2.3, figure TBDZMRZD</span>
<span class="cm"> * @enum znd_state</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">znd_state</span> <span class="p">{</span>
	<span class="n">ZND_STATE_EMPTY</span>		<span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>	<span class="c1">///&lt; ZND_STATE_EMPTY</span>
	<span class="n">ZND_STATE_IOPEN</span>		<span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>	<span class="c1">///&lt; ZND_STATE_IOPEN</span>
	<span class="n">ZND_STATE_EOPEN</span>		<span class="o">=</span> <span class="mh">0x3</span><span class="p">,</span>	<span class="c1">///&lt; ZND_STATE_EOPEN</span>
	<span class="n">ZND_STATE_CLOSED</span>	<span class="o">=</span> <span class="mh">0x4</span><span class="p">,</span>	<span class="c1">///&lt; ZND_STATE_CLOSED</span>
	<span class="n">ZND_STATE_RONLY</span>		<span class="o">=</span> <span class="mh">0xD</span><span class="p">,</span>	<span class="c1">///&lt; ZND_STATE_RONLY</span>
	<span class="n">ZND_STATE_FULL</span>		<span class="o">=</span> <span class="mh">0xE</span><span class="p">,</span>	<span class="c1">///&lt; ZND_STATE_FULL</span>
	<span class="n">ZND_STATE_OFFLINE</span>	<span class="o">=</span> <span class="mh">0xF</span><span class="p">,</span>	<span class="c1">///&lt; ZND_STATE_OFFLINE</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Produces a string representation of the given ::znd_state</span>
<span class="cm"> *</span>
<span class="cm"> * @param state the enum value produce a string representation of</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, a string representation is returned. On error, the string</span>
<span class="cm"> * &quot;ZND_STATE_ENOSYS&quot; is returned.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span>
<span class="nf">znd_state_str</span><span class="p">(</span><span class="k">enum</span> <span class="n">znd_state</span> <span class="n">state</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Identify controller accessor only for Zoned specific fields</span>
<span class="cm"> *</span>
<span class="cm"> * @see Specification, section 3.1.2</span>
<span class="cm"> * @struct znd_idfy_ctrlr</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">znd_idfy_ctrlr</span> <span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">zasl</span><span class="p">;</span>		<span class="c1">///&lt; Zone Append Size Limit</span>

	<span class="kt">uint8_t</span> <span class="n">rsvd8</span><span class="p">[</span><span class="mi">4095</span><span class="p">];</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">znd_idfy_ctrlr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4096</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given ::znd_idfy_ctrlr to the given output stream</span>
<span class="cm"> *</span>
<span class="cm"> * Only fields specific to Zoned Namespaces are printed by this function</span>
<span class="cm"> *</span>
<span class="cm"> * @param stream output stream used for printing</span>
<span class="cm"> * @param zctrlr pointer to the structure to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the number of characters printed is returned</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="n">znd_idfy_ctrlr_fpr</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="k">struct</span> <span class="n">znd_idfy_ctrlr</span> <span class="o">*</span><span class="n">zctrlr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given ::znd_idfy_ctrlr to the given output stream</span>
<span class="cm"> *</span>
<span class="cm"> * Only fields specific to Zoned Namespaces are printed by this function</span>
<span class="cm"> *</span>
<span class="cm"> * @param zctrlr pointer to the structure to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the number of characters printed is returned</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">znd_idfy_ctrlr_pr</span><span class="p">(</span><span class="k">struct</span> <span class="n">znd_idfy_ctrlr</span> <span class="o">*</span><span class="n">zctrlr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * LBA Format Extension</span>
<span class="cm"> *</span>
<span class="cm"> * @see Specification Section 5.1.2, figure LBAFE</span>
<span class="cm"> *</span>
<span class="cm"> * @struct znd_idfy_lbafe</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">znd_idfy_lbafe</span> <span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">zsze</span><span class="p">;</span>		<span class="c1">///&lt; Zone Size in number of logical blocks</span>
	<span class="kt">uint8_t</span> <span class="n">zdes</span><span class="p">;</span>		<span class="c1">///&lt; Zone Descriptor Extensions Size</span>

	<span class="kt">uint8_t</span> <span class="n">rsvd</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">znd_idfy_lbafe</span><span class="p">)</span> <span class="o">==</span> <span class="mi">16</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given ::znd_idfy_lbafe to the given output stream</span>
<span class="cm"> *</span>
<span class="cm"> * @param stream output stream used for printing</span>
<span class="cm"> * @param zonef pointer to structure to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the number of characters printed is returned</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="n">znd_idfy_lbafe_fpr</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="k">struct</span> <span class="n">znd_idfy_lbafe</span> <span class="o">*</span><span class="n">zonef</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Zoned Command Set specific identify namespace data structure</span>
<span class="cm"> *</span>
<span class="cm"> * @see TP4053, section 3</span>
<span class="cm"> * @struct znd_idfy_ns</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">znd_idfy_ns</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">uint16_t</span> <span class="nl">vzcap</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">///&lt; Variable Zone Capacity</span>
		<span class="kt">uint16_t</span> <span class="nl">zae</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">///&lt; Zone Active Excursions</span>

		<span class="kt">uint16_t</span> <span class="nl">rsvd</span>	<span class="p">:</span> <span class="mi">14</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">zoc</span><span class="p">;</span> <span class="c1">///&lt; Zone Operation Characteristics</span>

	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">uint16_t</span> <span class="nl">razb</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">///&lt; Read Across zone boundaries</span>

		<span class="kt">uint16_t</span> <span class="nl">rsvd</span>	<span class="p">:</span> <span class="mi">15</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ozcs</span><span class="p">;</span> <span class="c1">///&lt; Optional Zoned Command Support</span>

	<span class="kt">uint32_t</span> <span class="n">mar</span><span class="p">;</span>		<span class="c1">///&lt; Maximum Active Resources</span>
	<span class="kt">uint32_t</span> <span class="n">mor</span><span class="p">;</span>		<span class="c1">///&lt; Maximum Open Resources</span>

	<span class="kt">uint32_t</span> <span class="n">rrl</span><span class="p">;</span>		<span class="c1">///&lt; Reset Recommended Limit</span>
	<span class="kt">uint32_t</span> <span class="n">frl</span><span class="p">;</span>		<span class="c1">///&lt; Finish Recommended Limit</span>

	<span class="kt">uint8_t</span> <span class="n">rsvd20_2815</span><span class="p">[</span><span class="mi">2796</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">znd_idfy_lbafe</span> <span class="n">lbafe</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

	<span class="kt">uint8_t</span> <span class="n">rsvd3072_3839</span><span class="p">[</span><span class="mi">768</span><span class="p">];</span>

	<span class="kt">uint8_t</span> <span class="n">vs</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>	<span class="c1">///&lt; Vendor Specific</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">znd_idfy_ns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4096</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given ::znd_idfy_ns to the given output stream</span>
<span class="cm"> *</span>
<span class="cm"> * Only fields specific to Zoned Namespaces are printed by this function</span>
<span class="cm"> *</span>
<span class="cm"> * @param stream output stream used for printing</span>
<span class="cm"> * @param zns pointer to the structure to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the number of characters printed is returned</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="n">znd_idfy_ns_fpr</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="k">struct</span> <span class="n">znd_idfy_ns</span> <span class="o">*</span><span class="n">zns</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given ::znd_idfy_ns to stdout</span>
<span class="cm"> *</span>
<span class="cm"> * @param zns pointer to ::znd_idfy_ns</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the number of characters printed is returned</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">znd_idfy_ns_pr</span><span class="p">(</span><span class="k">struct</span> <span class="n">znd_idfy_ns</span> <span class="o">*</span><span class="n">zns</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Representation of the NVMe Identify Namespace command completion result</span>
<span class="cm"> *</span>
<span class="cm"> * @struct znd_idfy</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">znd_idfy</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">xnvme_spec_idfy</span> <span class="n">base</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">znd_idfy_ctrlr</span> <span class="n">zctrlr</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">znd_idfy_ns</span> <span class="n">zns</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">znd_idfy</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4096</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cp">#define ZND_CHANGES_LEN 511</span>

<span class="cm">/**</span>
<span class="cm"> * Zone Identifier List as returned by get-log-page</span>
<span class="cm"> *</span>
<span class="cm"> * @see Specification Section 5.3.1.1, figure TBDZONELIST</span>
<span class="cm"> *</span>
<span class="cm"> * @struct znd_changes</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">znd_changes</span> <span class="p">{</span>
	<span class="kt">uint16_t</span> <span class="n">nidents</span><span class="p">;</span>			<span class="c1">///&lt; Number of Zone Identifiers</span>
	<span class="kt">uint8_t</span> <span class="n">rsvd2</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="kt">uint64_t</span> <span class="n">idents</span><span class="p">[</span><span class="n">ZND_CHANGES_LEN</span><span class="p">];</span>	<span class="c1">///&lt; Zone Identifiers</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">znd_changes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4096</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given ::znd_changes to the given output stream</span>
<span class="cm"> *</span>
<span class="cm"> * @param stream output stream used for printing</span>
<span class="cm"> * @param changes pointer to subject to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="n">znd_changes_fpr</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">znd_changes</span> <span class="o">*</span><span class="n">changes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Pretty-printer of ::znd_changes</span>
<span class="cm"> *</span>
<span class="cm"> * @param changes pointer to subject to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">znd_changes_pr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">znd_changes</span> <span class="o">*</span><span class="n">changes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Zone Descriptor as reported by Zone Management Receive command</span>
<span class="cm"> *</span>
<span class="cm"> * @see Specification Section 6.2.2.3, figure TBDZMRZD</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">znd_descr</span> <span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="nl">zt</span>		<span class="p">:</span> <span class="mi">4</span><span class="p">;</span>	<span class="c1">///&lt; Zone Type</span>
	<span class="kt">uint8_t</span> <span class="nl">rsvd0</span>		<span class="p">:</span> <span class="mi">4</span><span class="p">;</span>

	<span class="kt">uint8_t</span> <span class="nl">rsvd1</span>		<span class="p">:</span> <span class="mi">4</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="nl">zs</span>		<span class="p">:</span> <span class="mi">4</span><span class="p">;</span>	<span class="c1">///&lt; Zone State</span>

	<span class="cm">/**</span>
<span class="cm">	 * Zone Attributes</span>
<span class="cm">	 */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint8_t</span> <span class="nl">zfc</span><span class="p">:</span> <span class="mi">1</span><span class="p">;</span>		<span class="c1">///&lt; Zone Finished by controller</span>
			<span class="kt">uint8_t</span> <span class="nl">zfr</span><span class="p">:</span> <span class="mi">1</span><span class="p">;</span>		<span class="c1">///&lt; Zone Finish Recommended</span>
			<span class="kt">uint8_t</span> <span class="nl">rzr</span><span class="p">:</span> <span class="mi">1</span><span class="p">;</span>		<span class="c1">///&lt; Reset Zone Recommended</span>

			<span class="kt">uint8_t</span> <span class="nl">rsvd3</span> <span class="p">:</span> <span class="mi">4</span><span class="p">;</span>

			<span class="kt">uint8_t</span> <span class="nl">zdev</span><span class="p">:</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">///&lt; Zone Descriptor Valid</span>
		<span class="p">};</span>
		<span class="kt">uint8_t</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">za</span><span class="p">;</span>

	<span class="kt">uint8_t</span> <span class="n">rsvd7</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

	<span class="kt">uint64_t</span> <span class="n">zcap</span><span class="p">;</span>			<span class="c1">///&lt; Zone Capacity (in number of LBAs)</span>
	<span class="kt">uint64_t</span> <span class="n">zslba</span><span class="p">;</span>			<span class="c1">///&lt; Zone Start LBA</span>
	<span class="kt">uint64_t</span> <span class="n">wp</span><span class="p">;</span>			<span class="c1">///&lt; Write Pointer</span>
	<span class="kt">uint8_t</span> <span class="n">rsvd63</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">znd_descr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">64</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given ::znd_descr to the given stream</span>
<span class="cm"> *</span>
<span class="cm"> * @param stream output stream used for printing</span>
<span class="cm"> * @param descr the struct to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="n">znd_descr_fpr</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">znd_descr</span> <span class="o">*</span><span class="n">descr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given ::znd_descr to stdout</span>
<span class="cm"> *</span>
<span class="cm"> * @param descr the structure to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">znd_descr_pr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">znd_descr</span> <span class="o">*</span><span class="n">descr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Report Zones Data Structure header</span>
<span class="cm"> *</span>
<span class="cm"> * The first 16 bytes of the two Report Zoned data structures</span>
<span class="cm"> *</span>
<span class="cm"> * @see Specification Section 6.2.2.1, figure TBDZMRRZ</span>
<span class="cm"> * @see Specification Section 6.2.2.2, figure TBDZMRERZ</span>
<span class="cm"> * @struct znd_rprt_hdr</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">znd_rprt_hdr</span> <span class="p">{</span>
	<span class="cm">/**</span>
<span class="cm">	 * Number of zones in namespace when receiving with partial=0</span>
<span class="cm">	 * Number of zones in the data-buffer, when receiving with partial=1</span>
<span class="cm">	 */</span>
	<span class="kt">uint64_t</span> <span class="n">nzones</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">rsvd</span><span class="p">[</span><span class="mi">56</span><span class="p">];</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">znd_rprt_hdr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">64</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * Print the given ::znd_rprt_hdr to the given output stream</span>
<span class="cm"> *</span>
<span class="cm"> * @param stream output stream used for printing</span>
<span class="cm"> * @param hdr the struct to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="n">znd_rprt_hdr_fpr</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">znd_rprt_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Print the given ::znd_rprt_hdr to the stdout</span>
<span class="cm"> *</span>
<span class="cm"> * @param hdr the struct to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">znd_rprt_hdr_pr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">znd_rprt_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Submit, and optionally wait for completion of, a Zone Management Receive</span>
<span class="cm"> *</span>
<span class="cm"> * @note When `opts | CMD_MODE_SYNC` then `ret` is filled with completion entry</span>
<span class="cm"> * upon return</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> * @param nsid Namespace Identifier</span>
<span class="cm"> * @param slba Start LBA of the Zone to receive for</span>
<span class="cm"> * @param action the ::znd_recv_action to perform</span>
<span class="cm"> * @param sf the ::znd_recv_action_sf option</span>
<span class="cm"> * @param partial partial request</span>
<span class="cm"> * @param dbuf pointer to data payload</span>
<span class="cm"> * @param dbuf_nbytes pointer to meta payload</span>
<span class="cm"> * @param opts command-options, see ::xnvme_cmd_opts</span>
<span class="cm"> * @param ret Pointer to structure for async. context and NVMe completion</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, 0 is returned. On error, negative `errno` is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">znd_cmd_mgmt_recv</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">nsid</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">slba</span><span class="p">,</span>
		  <span class="k">enum</span> <span class="n">znd_recv_action</span> <span class="n">action</span><span class="p">,</span> <span class="k">enum</span> <span class="n">znd_recv_action_sf</span> <span class="n">sf</span><span class="p">,</span>
		  <span class="kt">uint8_t</span> <span class="n">partial</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dbuf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">dbuf_nbytes</span><span class="p">,</span>
		  <span class="kt">int</span> <span class="n">opts</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xnvme_req</span> <span class="o">*</span><span class="n">ret</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Submit, and optionally wait for completion of, a Zone Management Send</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> * @param nsid Namespace Identifier</span>
<span class="cm"> * @param zslba Start LBA of the Zone to manage</span>
<span class="cm"> * @param action Management action to perform with zone at zslba</span>
<span class="cm"> * @param sf the ::znd_send_action_sf option</span>
<span class="cm"> * @param dbuf For action=ZND_SEND_DESCRIPTOR provide buffer</span>
<span class="cm"> * @param opts command-options, see ::xnvme_cmd_opts</span>
<span class="cm"> * @param ret Pointer to structure for async. context and NVMe completion</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, 0 is returned. On error, negative `errno` is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">znd_cmd_mgmt_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">nsid</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">zslba</span><span class="p">,</span>
		  <span class="k">enum</span> <span class="n">znd_send_action</span> <span class="n">action</span><span class="p">,</span> <span class="k">enum</span> <span class="n">znd_send_action_sf</span> <span class="n">sf</span><span class="p">,</span>
		  <span class="kt">void</span> <span class="o">*</span><span class="n">dbuf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xnvme_req</span> <span class="o">*</span><span class="n">ret</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Submit, and optionally wait for completion of, a Zone Append</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> * @param nsid Namespace Identifier</span>
<span class="cm"> * @param zslba First LBA of the Zone to append to</span>
<span class="cm"> * @param nlb number of LBAs, this is zero-based value</span>
<span class="cm"> * @param dbuf pointer to data payload</span>
<span class="cm"> * @param mbuf pointer to meta payload</span>
<span class="cm"> * @param opts command-options, see ::xnvme_cmd_opts</span>
<span class="cm"> * @param ret Pointer to structure for async. context and NVMe completion</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, 0 is returned. On error, negative `errno` is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">znd_cmd_append</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">nsid</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">zslba</span><span class="p">,</span>
	       <span class="kt">uint16_t</span> <span class="n">nlb</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dbuf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mbuf</span><span class="p">,</span>
	       <span class="kt">int</span> <span class="n">opts</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xnvme_req</span> <span class="o">*</span><span class="n">ret</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Encapsulation of Zone Descriptors and Zone Descriptor Extensions</span>
<span class="cm"> *</span>
<span class="cm"> * This is not the structure from the Specification, rather, this encapsulates</span>
<span class="cm"> * it and provides MACRO-accessors and helper-functions to retrieve</span>
<span class="cm"> * zone-descriptors and when supported, extensions.</span>
<span class="cm"> *</span>
<span class="cm"> * For simplicity then only used the macros:</span>
<span class="cm"> *</span>
<span class="cm"> * ZND_REPORT_DESCR(rprt, nth)	- Access the &#39;nth&#39; descriptor (zero-based)</span>
<span class="cm"> * ZND_REPORT_DEXT(rprt, nth)	- Access the &#39;nth&#39; descr. extension (zero-based)</span>
<span class="cm"> *</span>
<span class="cm"> * However, when zdes_bytes is 0, then `descr` is accessible as a regular array</span>
<span class="cm"> * When zdes &gt; 0, then the ZND_REPORT_DESCR should be used to access Zone</span>
<span class="cm"> * Descriptors and ZND_REPORT_DEXT should be used to access Zone Descriptor</span>
<span class="cm"> * extension</span>
<span class="cm"> *</span>
<span class="cm"> * @struct znd_report</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">znd_report</span> <span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">nzones</span><span class="p">;</span>		<span class="c1">///&lt; Nr. of zones in device</span>
	<span class="kt">uint32_t</span> <span class="n">zd_nbytes</span><span class="p">;</span>		<span class="c1">///&lt; Zone Descriptor in &#39;B&#39;</span>
	<span class="kt">uint32_t</span> <span class="n">zdext_nbytes</span><span class="p">;</span>		<span class="c1">///&lt; Zone Descriptor Extension in &#39;B&#39;</span>

	<span class="kt">uint64_t</span> <span class="n">zslba</span><span class="p">;</span>			<span class="c1">///&lt; First Zone in the report</span>
	<span class="kt">uint64_t</span> <span class="n">zelba</span><span class="p">;</span>			<span class="c1">///&lt; Last Zone in the report</span>
	<span class="kt">uint32_t</span> <span class="n">nentries</span><span class="p">;</span>		<span class="c1">///&lt; Nr. of entries in report</span>

	<span class="kt">uint8_t</span> <span class="n">extended</span><span class="p">;</span>		<span class="c1">///&lt; Whether this report has extensions</span>
	<span class="kt">uint8_t</span> <span class="n">_pad</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="kt">uint64_t</span> <span class="n">zrent_nbytes</span><span class="p">;</span>		<span class="c1">///&lt; Zone Report Entry Size in &#39;B&#39;</span>

	<span class="kt">uint64_t</span> <span class="n">report_nbytes</span><span class="p">;</span>		<span class="c1">///&lt; Size of this struct in bytes</span>
	<span class="kt">uint64_t</span> <span class="n">entries_nbytes</span><span class="p">;</span>	<span class="c1">///&lt; Size of the entries in bytes</span>

	<span class="c1">///&lt; Array of structs, column format: `descr[,descr_ext]`</span>
	<span class="kt">uint8_t</span> <span class="n">storage</span><span class="p">[];</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">znd_report</span><span class="p">)</span> <span class="o">==</span> <span class="mi">64</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given ::znd_report to the given stream</span>
<span class="cm"> *</span>
<span class="cm"> * @param stream output stream used for printing</span>
<span class="cm"> * @param report pointer to the the ::znd_report to print</span>
<span class="cm"> * @param flags</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="n">znd_report_fpr</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">znd_report</span> <span class="o">*</span><span class="n">report</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given ::znd_report to stdout</span>
<span class="cm"> *</span>
<span class="cm"> * @param report</span>
<span class="cm"> * @param flags</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">znd_report_pr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">znd_report</span> <span class="o">*</span><span class="n">report</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Access Zone Descriptors, by entry index, in the given znd_report</span>
<span class="cm"> */</span>
<span class="cp">#define ZND_REPORT_DESCR(rprt, nth) \</span>
<span class="cp">	((struct znd_descr *)&amp;(rprt-&gt;storage[nth * rprt-&gt;zrent_nbytes]))</span>

<span class="cm">/**</span>
<span class="cm"> * Access Zone Descriptors Extensions, by entry index, in the given znd_report</span>
<span class="cm"> */</span>
<span class="cp">#define ZND_REPORT_DEXT(rprt, nth) \</span>
<span class="cp">	((!rprt-&gt;extended) ? \</span>
<span class="cp">	 NULL \</span>
<span class="cp">	 : \</span>
<span class="cp">	 ((void *)&amp;rprt-&gt;storage[nth * rprt-&gt;zrent_nbytes + rprt-&gt;zd_nbytes]))</span>

<span class="cm">/**</span>
<span class="cm"> * Retrieves a Zone Report from the namespace associated with the given `dev`,</span>
<span class="cm"> * reporting starting at the given `slba`, and limited to `limit` entries</span>
<span class="cm"> *</span>
<span class="cm"> * @note</span>
<span class="cm"> * Caller is responsible for de-allocating the returned structure using</span>
<span class="cm"> * xnvme_buf_virt_free()</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> * @param slba LBA of the first zone in the report</span>
<span class="cm"> * @param limit when 0 then provide a report for all zones start from slba.</span>
<span class="cm"> * Otherwise, provide a report for [slba, slba+limit]</span>
<span class="cm"> * @param extended When 0, the &quot;regular&quot; report is provided. When 1, then the</span>
<span class="cm"> * Extended Report is provided, if supported by device.</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, pointer to zoned report. On error, NULL is returned and</span>
<span class="cm"> * `errno` is set to indicate the error</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">znd_report</span> <span class="o">*</span>
<span class="nf">znd_report_from_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">slba</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">limit</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">extended</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Scan the &#39;report&#39; for a zone in the given &#39;state&#39; and store it in &#39;zlba&#39;</span>
<span class="cm"> *</span>
<span class="cm"> * @param report The report to scan</span>
<span class="cm"> * @param state The zone-state to scan for</span>
<span class="cm"> * @param zlba Pointer to store zlba to</span>
<span class="cm"> * @param opts Optional seed random-number generator, when 0 then time(NULL) is</span>
<span class="cm"> * used</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, 0 is returned. On error, negative `errno` is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">znd_report_find_arbitrary</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">znd_report</span> <span class="o">*</span><span class="n">report</span><span class="p">,</span> <span class="k">enum</span> <span class="n">znd_state</span> <span class="n">state</span><span class="p">,</span>
			  <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">zlba</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Fills &#39;zdescr&#39; with the Zone on the given &#39;dev&#39; that starts at &#39;slba&#39;</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev The device to receive descriptors from</span>
<span class="cm"> * @param slba The Zone Start LBA</span>
<span class="cm"> * @param zdescr Pointer to the descriptor the function should fill</span>
<span class="cm"> *</span>
<span class="cm"> * @return On succes, 0 is returned and &#39;zdescr&#39; filled with matching Zone</span>
<span class="cm"> * Descriptor. On error, negative ``errno`` is returned to indicate the error,</span>
<span class="cm"> * and the content of given &#39;zdescr&#39; is undefined.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">znd_descr_from_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">slba</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">znd_descr</span> <span class="o">*</span><span class="n">zdescr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Fills &#39;zdescr&#39; with the first Zone on the given &#39;dev&#39; in the given &#39;state&#39;</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev The device to receive descriptors from</span>
<span class="cm"> * @param state The state the Zone should be in</span>
<span class="cm"> * @param zdescr Pointer to the descriptor the function should fill</span>
<span class="cm"> *</span>
<span class="cm"> * @return On succes, 0 is returned and &#39;zdescr&#39; filled with matching Zone</span>
<span class="cm"> * Descriptor. On error, negative ``errno`` is returned to indicate the error,</span>
<span class="cm"> * and the content of given &#39;zdescr&#39; is undefined.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">znd_descr_from_dev_in_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">znd_state</span> <span class="n">state</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">znd_descr</span> <span class="o">*</span><span class="n">zdescr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Ask the given device for how many zones in the given state via receive-action</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev The device to stat</span>
<span class="cm"> * @param sfield Receive stats of the given ::znd_recv_action_sf</span>
<span class="cm"> * @param nzones Pointer to store result in</span>
<span class="cm"> *</span>
<span class="cm"> * @return On Success, 0 is returned and &#39;nzones&#39; filled with stat. On error,</span>
<span class="cm"> * negative ``errno`` is returned to indicate the error.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">znd_stat_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">znd_recv_action_sf</span> <span class="n">sfield</span><span class="p">,</span>
	     <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">nzones</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Returns a list of changes since the last report was retrieved</span>
<span class="cm"> *</span>
<span class="cm"> * @note</span>
<span class="cm"> * Invoking this function clears the changed log</span>
<span class="cm"> *</span>
<span class="cm"> * @note</span>
<span class="cm"> * Caller is responsible for de-allocating the returned structure using</span>
<span class="cm"> * `xnvme_buf_free`</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, pointer to namespace structure. On error, NULL is</span>
<span class="cm"> * returned and `errno` is set to indicate the error</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">znd_changes</span> <span class="o">*</span>
<span class="nf">znd_changes_from_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cp">#ifdef __cplusplus</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* __LIBZND_H */</span><span class="cp"></span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="xnvmec.html" class="btn btn-neutral float-right" title="xnvmec" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="znd.html" class="btn btn-neutral float-left" title="znd" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, xNVMe

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>