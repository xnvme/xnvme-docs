

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>xnvme: headers &mdash; xNVMe 0.0.17 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="lblk" href="lblk.html" />
    <link rel="prev" title="xnvme" href="xnvme.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> xNVMe
          

          
          </a>

          
            
            
              <div class="version">
                0.0.17
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../quick_start/index.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Tools</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">C APIs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="xnvme.html">xnvme</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">xnvme: headers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#libxnvme-h">libxnvme.h</a></li>
<li class="toctree-l3"><a class="reference internal" href="#libxnvme-spec-h">libxnvme_spec.h</a></li>
<li class="toctree-l3"><a class="reference internal" href="#libxnvme-util-h">libxnvme_util.h</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lblk.html">lblk</a></li>
<li class="toctree-l2"><a class="reference internal" href="lblk_headers.html">lblk: headers</a></li>
<li class="toctree-l2"><a class="reference internal" href="znd.html">znd</a></li>
<li class="toctree-l2"><a class="reference internal" href="znd_headers.html">znd: headers</a></li>
<li class="toctree-l2"><a class="reference internal" href="xnvmec.html">xnvmec</a></li>
<li class="toctree-l2"><a class="reference internal" href="xnvmec_headers.html">xnvmec: headers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../examples/index.html">C APIs: Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../backends/index.html">Backends</a></li>
<li class="toctree-l1"><a class="reference internal" href="../building/index.html">Building xNVMe from source</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">xNVMe</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">C APIs</a> &raquo;</li>
        
      <li>xnvme: headers</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/capis/xnvme_headers.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="xnvme-headers">
<span id="sec-c-apis-xnvme-headers"></span><h1>xnvme: headers<a class="headerlink" href="#xnvme-headers" title="Permalink to this headline">¶</a></h1>
<div class="section" id="libxnvme-h">
<h2>libxnvme.h<a class="headerlink" href="#libxnvme-h" title="Permalink to this headline">¶</a></h2>
<p>The base <strong>xNVMe</strong> C API header</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * Cross-platform I/O library for NVMe based devices</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) Simon A. F. Lund &lt;simon.lund@samsung.com&gt;</span>
<span class="cm"> * Copyright (C) Klaus B. A. Jensen &lt;k.jensen@samsung.com&gt;</span>
<span class="cm"> * SPDX-License-Identifier: Apache-2.0</span>
<span class="cm"> *</span>
<span class="cm"> * @file libxnvme.h</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __LIBXNVME_H</span>
<span class="cp">#define __LIBXNVME_H</span>

<span class="cp">#ifdef __cplusplus</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>
<span class="cp">#endif</span>

<span class="cp">#include</span> <span class="cpf">&lt;inttypes.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/queue.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;libxnvme_util.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;libxnvme_spec.h&gt;</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * Options for pretty-printer (``*_pr``, ``*_fpr``) functions</span>
<span class="cm"> *</span>
<span class="cm"> * @enum xnvme_pr</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">xnvme_pr</span> <span class="p">{</span>
	<span class="n">XNVME_PR_DEF</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>	<span class="c1">///&lt; XNVME_PR_DEF: Default options</span>
	<span class="n">XNVME_PR_YAML</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>	<span class="c1">///&lt; XNVME_PR_YAML: Print formatted as YAML</span>
	<span class="n">XNVME_PR_TERSE</span> <span class="o">=</span> <span class="mh">0x2</span>	<span class="c1">///&lt; XNVME_PR_TERSE: Print without formatting</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Array of version-strings for libraries bundled with xNVMe</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">xnvme_3p_ver</span><span class="p">[];</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given array of version-strings to the given output stream</span>
<span class="cm"> *</span>
<span class="cm"> * @param stream output stream used for printing</span>
<span class="cm"> * @param attr Pointer to the array of strings to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_3p_ver_fpr</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ver</span><span class="p">[],</span> <span class="k">enum</span> <span class="n">xnvme_pr</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given array of version-strings to stdout</span>
<span class="cm"> *</span>
<span class="cm"> * @param attr Pointer to the array of strings to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_3p_ver_pr</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ver</span><span class="p">[],</span> <span class="k">enum</span> <span class="n">xnvme_pr</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *</span>
<span class="cm"> * io_uring_setup() flags</span>
<span class="cm"> * @enum xnvme_async_opts</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">xnvme_async_opts</span> <span class="p">{</span>
	<span class="n">XNVME_ASYNC_IOPOLL</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>       <span class="c1">///&lt; XNVME_ASYNC_IOPOLL: io_context is polled</span>
	<span class="n">XNVME_ASYNC_SQPOLL</span> <span class="o">=</span> <span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1">///&lt; XNVME_ASYNC_SQPOLL: SQ poll thread</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Representation of xNVMe library backend attributes</span>
<span class="cm"> *</span>
<span class="cm"> * @struct xnvme_be_attr_list</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_be_attr</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>	<span class="c1">///&lt; Backend name</span>

	<span class="cm">/**</span>
<span class="cm">	 * The default URI &#39;scheme&#39;, as in, the URI-definition below:</span>
<span class="cm">	 *</span>
<span class="cm">	 * scheme:target[?option=val]</span>
<span class="cm">	 *</span>
<span class="cm">	 * For which this backend identifies devices</span>
<span class="cm">	 */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">schemes</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">nschemes</span><span class="p">;</span>		<span class="c1">///&lt; Number of schemes in &#39;schemes&#39;</span>
	<span class="kt">int</span> <span class="n">enabled</span><span class="p">;</span>		<span class="c1">///&lt; Whether the backend is &#39;enabled&#39;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given backend attribute to the given output stream</span>
<span class="cm"> *</span>
<span class="cm"> * @param stream output stream used for printing</span>
<span class="cm"> * @param attr Pointer to the ::xnvme_be_attr to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_be_attr_fpr</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_be_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given backend attribute to stdout</span>
<span class="cm"> *</span>
<span class="cm"> * @param attr Pointer to the ::xnvme_be_attr to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_be_attr_pr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_be_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * List of xNVMe library backend attributes</span>
<span class="cm"> *</span>
<span class="cm"> * @struct xnvme_be_attr_list</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_be_attr_list</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">capacity</span><span class="p">;</span>		<span class="c1">///&lt; Remaining unused entries</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>			<span class="c1">///&lt; Number of used entries</span>
	<span class="k">struct</span> <span class="n">xnvme_be_attr</span> <span class="n">item</span><span class="p">[];</span>	<span class="c1">///&lt; Array of items</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given backend attribute list to the given output stream</span>
<span class="cm"> *</span>
<span class="cm"> * @param stream output stream used for printing</span>
<span class="cm"> * @param list Pointer to the backend attribute list to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_be_attr_list_fpr</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_be_attr_list</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given backend attribute list to standard out</span>
<span class="cm"> *</span>
<span class="cm"> * @param list Pointer to the backend attribute list to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_be_attr_list_pr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_be_attr_list</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * List backends supported by the library</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, 0 is returned. On error, negative `errno` is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_be_attr_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_be_attr_list</span> <span class="o">**</span><span class="n">list</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given LBA to the given output stream</span>
<span class="cm"> *</span>
<span class="cm"> * @param stream output stream used for printing</span>
<span class="cm"> * @param lba the LBA to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_lba_fpr</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">lba</span><span class="p">,</span> <span class="k">enum</span> <span class="n">xnvme_pr</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given Logical Block Addresses (LBA) to stdout</span>
<span class="cm"> *</span>
<span class="cm"> * @param lba the LBA to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_lba_pr</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">lba</span><span class="p">,</span> <span class="k">enum</span> <span class="n">xnvme_pr</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given list of Logical Block Addresses (LBAs)to the given output</span>
<span class="cm"> * stream</span>
<span class="cm"> *</span>
<span class="cm"> * @param stream output stream used for printing</span>
<span class="cm"> * @param lba Pointer to an array of LBAs to print</span>
<span class="cm"> * @param nlb Number of LBAs to print from the given list</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_lba_fprn</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">lba</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">nlb</span><span class="p">,</span>
	       <span class="k">enum</span> <span class="n">xnvme_pr</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Print a list of Logical Block Addresses (LBAs)</span>
<span class="cm"> *</span>
<span class="cm"> * @param lba Pointer to an array of LBAs to print</span>
<span class="cm"> * @param nlb Length of the array in items</span>
<span class="cm"> * @param opts Printer options</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_lba_prn</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">lba</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">nlb</span><span class="p">,</span> <span class="k">enum</span> <span class="n">xnvme_pr</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Produces the &quot;major&quot; version of the library</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the &quot;major&quot; version of the library is returned</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_ver_major</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Produces the &quot;minor&quot; version of the library</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the &quot;minor&quot; version of the library is returned</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_ver_minor</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Produces the &quot;patch&quot; version of the library</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the &quot;patch&quot; version of the library is returned</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_ver_patch</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the library version to the given &#39;stream&#39;</span>
<span class="cm"> *</span>
<span class="cm"> * @param stream output stream used for printing</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_ver_fpr</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the library version to stdout</span>
<span class="cm"> *</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_ver_pr</span><span class="p">(</span><span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Enumeration of `xnvme_cmd` options</span>
<span class="cm"> *</span>
<span class="cm"> * @enum xnvme_cmd_opts</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">xnvme_cmd_opts</span> <span class="p">{</span>
	<span class="n">XNVME_CMD_SYNC</span>		<span class="o">=</span> <span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>	<span class="c1">///&lt; XNVME_CMD_SYNC: Synchronous command</span>
	<span class="n">XNVME_CMD_ASYNC</span>		<span class="o">=</span> <span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>	<span class="c1">///&lt; XNVME_CMD_ASYNC: Asynchronous command</span>

	<span class="n">XNVME_CMD_UPLD_SGLD</span>	<span class="o">=</span> <span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>	<span class="c1">///&lt; XNVME_CMD_UPLD_SGLD: User-managed SGL data</span>
	<span class="n">XNVME_CMD_UPLD_SGLM</span>	<span class="o">=</span> <span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span>	<span class="c1">///&lt; XNVME_CMD_UPLD_SGLM: User-managed SGL meta</span>
<span class="p">};</span>

<span class="cp">#define XNVME_CMD_MASK_IOMD ( XNVME_CMD_SYNC | XNVME_CMD_ASYNC )</span>
<span class="cp">#define XNVME_CMD_MASK_UPLD ( XNVME_CMD_UPLD_SGLD | XNVME_CMD_UPLD_SGLM )</span>
<span class="cp">#define XNVME_CMD_MASK ( XNVME_CMD_MASK_IOMD | XNVME_CMD_MASK_UPLD )</span>

<span class="cp">#define XNVME_CMD_DEF_IOMD XNVME_CMD_SYNC</span>
<span class="cp">#define XNVME_CMD_DEF_UPLD ( 0x0 )</span>

<span class="cp">#define XNVME_IDENT_URI_LEN 384</span>
<span class="cp">#define XNVME_IDENT_URI_LEN_MIN 10</span>

<span class="cp">#define XNVME_IDENT_SCHM_LEN 5</span>
<span class="cp">#define XNVME_IDENT_TRGT_LEN 155</span>
<span class="cp">#define XNVME_IDENT_OPTS_LEN 160</span>
<span class="cp">#define XNVME_IDENT_OPTS_SEP &#39;?&#39;</span>

<span class="cm">/**</span>
<span class="cm"> * Representation of device identifiers once decoded from text-representation</span>
<span class="cm"> *</span>
<span class="cm"> * @struct xnvme_ident</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_ident</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">uri</span><span class="p">[</span><span class="n">XNVME_IDENT_URI_LEN</span><span class="p">];</span>

	<span class="kt">char</span> <span class="n">schm</span><span class="p">[</span><span class="n">XNVME_IDENT_SCHM_LEN</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">trgt</span><span class="p">[</span><span class="n">XNVME_IDENT_TRGT_LEN</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">opts</span><span class="p">[</span><span class="n">XNVME_IDENT_OPTS_LEN</span><span class="p">];</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_ident</span><span class="p">)</span> <span class="o">==</span> <span class="mi">704</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given ::xnvme_ident to the given output stream</span>
<span class="cm"> *</span>
<span class="cm"> * @param stream output stream used for printing</span>
<span class="cm"> * @param ident pointer to structure to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="n">xnvme_ident_fpr</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_ident</span> <span class="o">*</span><span class="n">ident</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given ::xnvme_ident to stdout</span>
<span class="cm"> *</span>
<span class="cm"> * @param ident pointer to structure to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_ident_pr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_ident</span> <span class="o">*</span><span class="n">ident</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Parse the given &#39;uri&#39; into &#39;ident&#39;</span>
<span class="cm"> *</span>
<span class="cm"> * @param uri</span>
<span class="cm"> * @param ident Pointer to ident to fill with values parsed from &#39;ident_uri&#39;</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, 0 is returned. On error, negative `errno` is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_ident_from_uri</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">uri</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xnvme_ident</span> <span class="o">*</span><span class="n">ident</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * List of devices found on the system usable with xNVMe</span>
<span class="cm"> *</span>
<span class="cm"> * @struct xnvme_sys_list</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_enumeration</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">capacity</span><span class="p">;</span>		<span class="c1">///&lt; Remaining unused entries</span>
	<span class="kt">uint32_t</span> <span class="n">nentries</span><span class="p">;</span>		<span class="c1">///&lt; Used entries</span>
	<span class="k">struct</span> <span class="n">xnvme_ident</span> <span class="n">entries</span><span class="p">[];</span>	<span class="c1">///&lt; Device entries</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given ::xnvme_enumeration to the given output stream</span>
<span class="cm"> *</span>
<span class="cm"> * @param stream output stream used for printing</span>
<span class="cm"> * @param list pointer to structure to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_enumeration_fpr</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xnvme_enumeration</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given ::xnvme_enumeration to stdout</span>
<span class="cm"> *</span>
<span class="cm"> * @param list pointer to structure to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_enumeration_pr</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_enumeration</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Enumerate devices on the given system</span>
<span class="cm"> *</span>
<span class="cm"> * @param list Pointer to pointer of the list of device enumerated</span>
<span class="cm"> * @param sys_uri URI of the system to enumerate on, when NULL, localhost/PCIe</span>
<span class="cm"> * @param opts System enumeration options</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, 0 is returned. On error, negative `errno` is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_enumerate</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_enumeration</span> <span class="o">**</span><span class="n">list</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sys_uri</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Opaque device handle.</span>
<span class="cm"> *</span>
<span class="cm"> * @struct xnvme_dev</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_dev</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given ::xnvme_dev to the given output stream</span>
<span class="cm"> *</span>
<span class="cm"> * @param stream output stream used for printing</span>
<span class="cm"> * @param dev pointer to structure to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_dev_fpr</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given ::xnvme_dev to stdout</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev pointer to structure to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_dev_pr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Allocate a buffer for IO with the given device</span>
<span class="cm"> *</span>
<span class="cm"> * The buffer will be aligned to device geometry and DMA allocated if required</span>
<span class="cm"> * by the backend for IO</span>
<span class="cm"> *</span>
<span class="cm"> * @note</span>
<span class="cm"> * nbytes must be greater than zero and a multiple of minimal granularity</span>
<span class="cm"> * @note</span>
<span class="cm"> * De-allocate the buffer using xnvme_buf_free()</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> * @param nbytes The size of the allocated buffer in bytes</span>
<span class="cm"> * @param phys A pointer to the variable to hold the physical address of the</span>
<span class="cm"> * allocated buffer. If NULL, the physical address is not returned.</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, a pointer to the allocated memory is returned. On error,</span>
<span class="cm"> * NULL is returned and `errno` set to indicate the error.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span>
<span class="nf">xnvme_buf_alloc</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">phys</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Reallocate a buffer for IO with the given device</span>
<span class="cm"> *</span>
<span class="cm"> * The buffer will be aligned to device geometry and DMA allocated if required</span>
<span class="cm"> * by the backend for IO</span>
<span class="cm"> *</span>
<span class="cm"> * @note</span>
<span class="cm"> * nbytes must be greater than zero and a multiple of minimal granularity</span>
<span class="cm"> * @note</span>
<span class="cm"> * De-allocate the buffer using xnvme_buf_free()</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> * @param buf The buffer to reallocate</span>
<span class="cm"> * @param nbytes The size of the allocated buffer in bytes</span>
<span class="cm"> * @param phys A pointer to the variable to hold the physical address of the</span>
<span class="cm"> * allocated buffer. If NULL, the physical address is not returned.</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, a pointer to the allocated memory is returned. On error,</span>
<span class="cm"> * NULL is returned and `errno` set to indicate the error.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span>
<span class="nf">xnvme_buf_realloc</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">,</span>
		  <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">phys</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Free the given IO buffer allocated with xnvme_buf_alloc()</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> * @param buf Pointer to a buffer allocated with xnvme_buf_alloc()</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xnvme_buf_free</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Retrieve the physical address of the given buffer</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> * @param buf Pointer to a buffer allocated with xnvme_buf_alloc()</span>
<span class="cm"> * @param phys A pointer to the variable to hold the physical address of the</span>
<span class="cm"> * given buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, 0 is returned. On error, negative `errno` is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_buf_vtophys</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">phys</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Allocate a buffer of virtual memory of the given `alignment` and `nbytes`</span>
<span class="cm"> *</span>
<span class="cm"> * @note</span>
<span class="cm"> * You must use xnvme_buf_virt_free() to de-allocate the buffer</span>
<span class="cm"> *</span>
<span class="cm"> * @param alignment The alignment in bytes</span>
<span class="cm"> * @param nbytes The size of the buffer in bytes</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, a pointer to the allocated memory is return. On error,</span>
<span class="cm"> * NULL is returned and `errno` set to indicate the error</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span>
<span class="nf">xnvme_buf_virt_alloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">alignment</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Free the given virtual memory buffer</span>
<span class="cm"> *</span>
<span class="cm"> * @param buf Pointer to a buffer allocated with xnvme_buf_virt_alloc()</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xnvme_buf_virt_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Opaque handle for Scatter Gather List (SGL).</span>
<span class="cm"> *</span>
<span class="cm"> * @struct xnvme_sgl</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_sgl</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * Opaque handle for Scatter Gather List (SGL) pool</span>
<span class="cm"> *</span>
<span class="cm"> * @note A separate pool should be used for each asynchronous context</span>
<span class="cm"> *</span>
<span class="cm"> * @struct xnvme_sgl_pool</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_sgl_pool</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * Create an pool of Scather-Gather-List (SGL)</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> *</span>
<span class="cm"> * @return An initialized pool that can be used to amortize the cost of repeated</span>
<span class="cm"> * SGL allocations</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_sgl_pool</span> <span class="o">*</span>
<span class="nf">xnvme_sgl_pool_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Destroy an SGL pool (and all SGLs in the pool).</span>
<span class="cm"> *</span>
<span class="cm"> * @param pool Pointer to the #xnvme_sgl_pool to destroy</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xnvme_sgl_pool_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_sgl_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Create a Scatter-Gather-List (SGL)</span>
<span class="cm"> *</span>
<span class="cm"> * @see xnvme_sgl_destroy</span>
<span class="cm"> * @see xnvme_sgl_alloc</span>
<span class="cm"> * @see xnvme_sgl_free</span>
<span class="cm"> * @see xnvme_sgl_add</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> * @param hint Allocation hint.</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, an initialized (empty) SGL is returned. On error, NULL is</span>
<span class="cm"> * returned and `errno` is set to indicate any error.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_sgl</span> <span class="o">*</span>
<span class="nf">xnvme_sgl_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hint</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Destroy an SGL, freeing the memory used</span>
<span class="cm"> *</span>
<span class="cm"> * @see xnvme_sgl_free</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> * @param sgl Pointer to SGL as allocated by xnvme_sgl_alloc() or</span>
<span class="cm"> * xnvme_sgl_create()</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xnvme_sgl_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xnvme_sgl</span> <span class="o">*</span><span class="n">sgl</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Allocate an SGL from a pool</span>
<span class="cm"> *</span>
<span class="cm"> * @see xnvme_sgl_create</span>
<span class="cm"> *</span>
<span class="cm"> * @param pool Pool to allocate SGL from</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, an initialized (empty) SGL is returned. On error, NULL is</span>
<span class="cm"> * returned and `errno` is set to indicate any error.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_sgl</span> <span class="o">*</span>
<span class="nf">xnvme_sgl_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_sgl_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Free an SGL, returning it to the pool</span>
<span class="cm"> *</span>
<span class="cm"> * @see xnvme_sgl_destroy</span>
<span class="cm"> *</span>
<span class="cm"> * @param pool Pool to return the given `sgl` to</span>
<span class="cm"> * @param sgl Pointer to SGL as allocated by xnvme_sgl_alloc() or</span>
<span class="cm"> *  xnvme_sgl_create()</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xnvme_sgl_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_sgl_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xnvme_sgl</span> <span class="o">*</span><span class="n">sgl</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Reset an SGL</span>
<span class="cm"> *</span>
<span class="cm"> * @param sgl Pointer to SGL as allocated by xnvme_sgl_alloc() or</span>
<span class="cm"> * xnvme_sgl_create()</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xnvme_sgl_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_sgl</span> <span class="o">*</span><span class="n">sgl</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Add an entry to the SGL</span>
<span class="cm"> *</span>
<span class="cm"> * @see xnvme_sgl_alloc</span>
<span class="cm"> * @see xnvme_buf_alloc</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> * @param sgl Pointer to sgl as allocated by xnvme_sgl_alloc()</span>
<span class="cm"> * @param buf Pointer to buffer as allocated with xnvme_buf_alloc()</span>
<span class="cm"> * @param nbytes Size of the given buffer in bytes</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_sgl_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xnvme_sgl</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
	      <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Opaque asynchronous context as provided by xnvme_async_init()</span>
<span class="cm"> *</span>
<span class="cm"> * @see xnvme_async_init</span>
<span class="cm"> * @see xnvme_async_term</span>
<span class="cm"> *</span>
<span class="cm"> * @struct xnvme_async_ctx</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_async_ctx</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * Allocate an asynchronous context for command submission of the given depth</span>
<span class="cm"> * for submission of commands to the given device</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> * @param ctx Pointer-pointer to initialized context</span>
<span class="cm"> * @param depth Maximum iodepth / qdepth, maximum number of outstanding commands</span>
<span class="cm"> * of the returned context, note that is must be a power of 2 within the range</span>
<span class="cm"> * [1,4096]</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, 0 is returned. On error, negative `errno` is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_async_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xnvme_async_ctx</span> <span class="o">**</span><span class="n">ctx</span><span class="p">,</span>
		 <span class="kt">uint16_t</span> <span class="n">depth</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Get the I/O depth of the context.</span>
<span class="cm"> *</span>
<span class="cm"> * @param ctx Asynchronous context</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, depth of the given context is returned. On error, 0 is</span>
<span class="cm"> * returned e.g. errors are silent</span>
<span class="cm"> */</span>
<span class="kt">uint32_t</span>
<span class="nf">xnvme_async_get_depth</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_async_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Get the number of outstanding I/O.</span>
<span class="cm"> *</span>
<span class="cm"> * @param ctx Asynchronous context</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, number of outstanding commands are returned. On error, 0</span>
<span class="cm"> * is returned e.g. errors are silent</span>
<span class="cm"> */</span>
<span class="kt">uint32_t</span>
<span class="nf">xnvme_async_get_outstanding</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_async_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Tear down the given Asynchronous context</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> * @param ctx</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, 0 is returned. On error, negative `errno` is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_async_term</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xnvme_async_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Process completions from the given Asynchronous context</span>
<span class="cm"> *</span>
<span class="cm"> * Set process &#39;max&#39; to limit number of completions, 0 means no max.</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, number of completions processed, may be 0. On error,</span>
<span class="cm"> * negative `errno` is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_async_poke</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xnvme_async_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
		 <span class="kt">uint32_t</span> <span class="n">max</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Wait for completion of all outstanding commands in the given &#39;ctx&#39;</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, number of completions processed, may be 0. On error,</span>
<span class="cm"> * negative `errno` is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_async_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xnvme_async_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Forward declaration, see definition further down</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_req</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">xnvme_req_pool</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * Signature of function used with asynchronous callbacks.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">xnvme_async_cb</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xnvme_req</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Encapsulation and representation of lower-level error conditions</span>
<span class="cm"> *</span>
<span class="cm"> * @struct xnvme_req</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">xnvme_spec_cpl</span> <span class="n">cpl</span><span class="p">;</span>		<span class="c1">///&lt; NVMe completion</span>

	<span class="c1">///&lt; Fields for CMD_OPT: XNVME_CMD_ASYNC</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">xnvme_async_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>	<span class="c1">///&lt; Asynchronous context</span>
		<span class="n">xnvme_async_cb</span> <span class="n">cb</span><span class="p">;</span>		<span class="c1">///&lt; User callback function</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">cb_arg</span><span class="p">;</span>			<span class="c1">///&lt; User callback arguments</span>

		<span class="c1">///&lt; Per request backend specific data</span>
		<span class="kt">uint8_t</span> <span class="n">be_rsvd</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">async</span><span class="p">;</span>

	<span class="c1">///&lt; Fields for request-pool</span>
	<span class="k">struct</span> <span class="n">xnvme_req_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">;</span>
	<span class="n">SLIST_ENTRY</span><span class="p">(</span><span class="n">xnvme_req</span><span class="p">)</span> <span class="n">link</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">xnvme_req_pool</span> <span class="p">{</span>
	<span class="n">SLIST_HEAD</span><span class="p">(,</span> <span class="n">xnvme_req</span><span class="p">)</span> <span class="n">head</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">capacity</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xnvme_req</span> <span class="n">elm</span><span class="p">[];</span>
<span class="p">};</span>

<span class="kt">int</span>
<span class="nf">xnvme_req_pool_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_req_pool</span> <span class="o">**</span><span class="n">pool</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">capacity</span><span class="p">);</span>

<span class="kt">int</span>
<span class="nf">xnvme_req_pool_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_req_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xnvme_async_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
		    <span class="n">xnvme_async_cb</span> <span class="n">cb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cb_args</span><span class="p">);</span>

<span class="kt">void</span>
<span class="nf">xnvme_req_pool_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_req_pool</span> <span class="o">*</span><span class="n">pool</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints a humanly readable representation the given #xnvme_req</span>
<span class="cm"> *</span>
<span class="cm"> * @param req Pointer to the #xnvme_req to print</span>
<span class="cm"> * @param opts Printer options</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xnvme_req_pr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_req</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Clears/resets the given #xnvme_req</span>
<span class="cm"> *</span>
<span class="cm"> * @param req Pointer to the #xnvme_req to clear</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xnvme_req_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_req</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Encapsulate completion-error checking here for now.</span>
<span class="cm"> *</span>
<span class="cm"> * @todo re-think this</span>
<span class="cm"> * @param req Pointer to the #xnvme_req to check status on</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, 0 is return. On error, a non-zero value is returned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">xnvme_req_cpl_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_req</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">cpl</span><span class="p">.</span><span class="n">status</span><span class="p">.</span><span class="n">sc</span> <span class="o">||</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">cpl</span><span class="p">.</span><span class="n">status</span><span class="p">.</span><span class="n">sct</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Representation of the type of device / geo / namespace</span>
<span class="cm"> *</span>
<span class="cm"> * @enum xnvme_geo_type</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">xnvme_geo_type</span> <span class="p">{</span>
	<span class="n">XNVME_GEO_UNKNOWN</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>
	<span class="n">XNVME_GEO_CONVENTIONAL</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
	<span class="n">XNVME_GEO_ZONED</span> <span class="o">=</span> <span class="mh">0x2</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Representation of device &quot;geometry&quot;</span>
<span class="cm"> *</span>
<span class="cm"> * This will remain in some, encapsulating IO parameters such as MDTS, ZONE</span>
<span class="cm"> * APPEND MDTS, nbytes, nsect etc. mapping to zone characteristics, as well as</span>
<span class="cm"> * extended LBA formats.</span>
<span class="cm"> *</span>
<span class="cm"> * @struct xnvme_geo</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_geo</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">xnvme_geo_type</span> <span class="n">type</span><span class="p">;</span>

	<span class="kt">uint32_t</span> <span class="n">npugrp</span><span class="p">;</span>	<span class="c1">///&lt; Nr. of Parallel Unit Groups</span>
	<span class="kt">uint32_t</span> <span class="n">npunit</span><span class="p">;</span>	<span class="c1">///&lt; Nr. of Parallel Units in PUG</span>

	<span class="kt">uint32_t</span> <span class="n">nzone</span><span class="p">;</span>		<span class="c1">///&lt; Nr. of zones in PU</span>
	<span class="kt">uint64_t</span> <span class="n">nsect</span><span class="p">;</span>		<span class="c1">///&lt; Nr. of sectors per zone</span>
	<span class="kt">uint32_t</span> <span class="n">nbytes</span><span class="p">;</span>	<span class="c1">///&lt; Nr. of bytes per sector</span>
	<span class="kt">uint32_t</span> <span class="n">nbytes_oob</span><span class="p">;</span>	<span class="c1">///&lt; Nr. of bytes per sector in OOB</span>

	<span class="kt">uint64_t</span> <span class="n">tbytes</span><span class="p">;</span>	<span class="c1">///&lt; Total # bytes in geometry</span>

	<span class="kt">uint32_t</span> <span class="n">mdts_nbytes</span><span class="p">;</span>	<span class="c1">///&lt; Maximum-data-transfer-size in unit of bytes</span>

	<span class="kt">uint32_t</span> <span class="n">lba_nbytes</span><span class="p">;</span>	<span class="c1">///&lt; Size of an LBA in bytes</span>
	<span class="kt">uint8_t</span> <span class="n">lba_extended</span><span class="p">;</span>	<span class="c1">///&lt; Extended LBA: 1=Supported, 0=Not-Supported</span>

	<span class="kt">uint8_t</span> <span class="n">_rsvd</span><span class="p">[</span><span class="mi">15</span><span class="p">];</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_geo</span><span class="p">)</span> <span class="o">==</span> <span class="mi">64</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given ::xnvme_geo to the given output stream</span>
<span class="cm"> *</span>
<span class="cm"> * @param stream output stream used for printing</span>
<span class="cm"> * @param geo pointer to the the ::xnvme_geo to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="n">xnvme_geo_fpr</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_geo</span> <span class="o">*</span><span class="n">geo</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given ::xnvme_geo to stdout</span>
<span class="cm"> *</span>
<span class="cm"> * @param geo pointer to the the ::xnvme_geo to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_geo_pr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_geo</span> <span class="o">*</span><span class="n">geo</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Pass a NVMe IO Command through to the device with minimal intervention</span>
<span class="cm"> *</span>
<span class="cm"> * When constructing the command then take note of the following:</span>
<span class="cm"> *</span>
<span class="cm"> * - The CID is managed at a lower level and probably over-written if assigned</span>
<span class="cm"> * - When &#39;opts&#39; include XNVME_CMD_PRP then just pass buffers allocated with</span>
<span class="cm"> *   `xnvme_buf_alloc`, the construction of PRP-lists, assignment to command and</span>
<span class="cm"> *   assignment of pdst is managed at lower levels</span>
<span class="cm"> * - When &#39;opts&#39;&#39; include XNVME_CMD_SGL then both data, and meta, when given</span>
<span class="cm"> *   must be setup via the `xnvme_sgl` helper functions, pdst, data, and meta</span>
<span class="cm"> *   fields must be also be set by you</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> * @param cmd Pointer to the NVMe command to submit</span>
<span class="cm"> * @param dbuf pointer to data-payload</span>
<span class="cm"> * @param dbuf_nbytes size of data-payload in bytes</span>
<span class="cm"> * @param mbuf pointer to meta-payload</span>
<span class="cm"> * @param mbuf_nbytes size of the meta-payload in bytes</span>
<span class="cm"> * @param opts Command options; see</span>
<span class="cm"> * @param req Pointer to structure for async. context and NVMe completion</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, 0 is returned. On error, negative `errno` is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_cmd_pass</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xnvme_spec_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dbuf</span><span class="p">,</span>
	       <span class="kt">size_t</span> <span class="n">dbuf_nbytes</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mbuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">mbuf_nbytes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">xnvme_req</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Pass a NVMe Admin Command through to the device with minimal intervention</span>
<span class="cm"> *</span>
<span class="cm"> * When constructing the command then take note of the following:</span>
<span class="cm"> *</span>
<span class="cm"> * - The CID is managed at a lower level and probably over-written if assigned</span>
<span class="cm"> * - When &#39;opts&#39; include XNVME_CMD_PRP then just pass buffers allocated with</span>
<span class="cm"> *   `xnvme_buf_alloc`, the construction of PRP-lists, assignment to command and</span>
<span class="cm"> *   assignment of pdst is managed at lower levels</span>
<span class="cm"> * - When &#39;opts&#39;&#39; include XNVME_CMD_SGL then both data, and meta, when given</span>
<span class="cm"> *   must be setup via the `xnvme_sgl` helper functions, pdst, data, and meta</span>
<span class="cm"> *   fields must be also be set by you</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> * @param cmd Pointer to the NVMe command to submit</span>
<span class="cm"> * @param dbuf pointer to data-payload</span>
<span class="cm"> * @param dbuf_nbytes size of data-payload in bytes</span>
<span class="cm"> * @param mbuf pointer to meta-payload</span>
<span class="cm"> * @param mbuf_nbytes size of the meta-payload in bytes</span>
<span class="cm"> * @param opts Command options; see</span>
<span class="cm"> * @param req Pointer to structure for async. context and NVMe completion</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, 0 is returned. On error, negative `errno` is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_cmd_pass_admin</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xnvme_spec_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
		     <span class="kt">void</span> <span class="o">*</span><span class="n">dbuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">dbuf_nbytes</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mbuf</span><span class="p">,</span>
		     <span class="kt">size_t</span> <span class="n">mbuf_nbytes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xnvme_req</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Submit and wait for completion of an NVMe Identify command</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> * @param cns the ::xnvme_spec_idfy_cns to retrieve</span>
<span class="cm"> * @param cntid Controller Identifier</span>
<span class="cm"> * @param nsid Namespace Identifier</span>
<span class="cm"> * @param nvmsetid NVM set Identifier</span>
<span class="cm"> * @param uuid UUID index</span>
<span class="cm"> * @param dbuf ponter to data-payload</span>
<span class="cm"> * @param req Pointer to structure for NVMe completion</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, 0 is returned. On error, negative `errno` is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_cmd_idfy</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">cns</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">cntid</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">nsid</span><span class="p">,</span>
	       <span class="kt">uint16_t</span> <span class="n">nvmsetid</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">uuid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xnvme_spec_idfy</span> <span class="o">*</span><span class="n">dbuf</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">xnvme_req</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Submit and wait for completion of an NVMe Identify command for the</span>
<span class="cm"> * controller associated with the given device</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> * @param dbuf pointer to data-payload</span>
<span class="cm"> * @param req Pointer to structure for NVMe completion</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, 0 is returned. On error, negative `errno` is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_cmd_idfy_ctrlr</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xnvme_spec_idfy</span> <span class="o">*</span><span class="n">dbuf</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">xnvme_req</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Submit and wait for completion of an NVMe Identify command for the</span>
<span class="cm"> * controller associated with the given device</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> * @param csi Command Set Identifier</span>
<span class="cm"> * @param dbuf Buffer allocated by xnvme_buf_alloc()</span>
<span class="cm"> * @param req Pointer to structure for NVMe completion</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, 0 is returned. On error, negative `errno` is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_cmd_idfy_ctrlr_csi</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">csi</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">xnvme_spec_idfy</span> <span class="o">*</span><span class="n">dbuf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xnvme_req</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Submit and wait for completion of an NVMe Identify command for the given nsid</span>
<span class="cm"> *</span>
<span class="cm"> * Execute an NVMe identify namespace command for the namespace associated with</span>
<span class="cm"> * the given &#39;dev&#39; when &#39;nsid&#39;=0, execute for the given &#39;nsid&#39; when it is &gt; 0,</span>
<span class="cm"> * when the given &#39;nsid&#39; == 0, then the command is executed for the namespace</span>
<span class="cm"> * associated with the given device</span>
<span class="cm"> *</span>
<span class="cm"> * @todo document</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> * @param nsid Namespace identifier</span>
<span class="cm"> * @param dbuf Buffer allocated by xnvme_buf_alloc()</span>
<span class="cm"> * @param req Pointer to structure for NVMe completion</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, 0 is returned. On error, negative `errno` is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_cmd_idfy_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">nsid</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">xnvme_spec_idfy</span> <span class="o">*</span><span class="n">dbuf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xnvme_req</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Submit and wait for completion of an NVMe Identify command for the given nsid</span>
<span class="cm"> *</span>
<span class="cm"> * Execute an I/O Command Set specific NVMe identify namespace command for the</span>
<span class="cm"> * given &#39;nsid&#39;. When the given &#39;nsid&#39; == 0, then the command is executed for</span>
<span class="cm"> * the namespace associated with the given device</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> * @param nsid Namespace identifier</span>
<span class="cm"> * @param csi Command Set Identifier</span>
<span class="cm"> * @param dbuf Buffer allocated by xnvme_buf_alloc()</span>
<span class="cm"> * @param req Pointer to structure for NVMe completion</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, 0 is returned. On error, negative `errno` is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_cmd_idfy_ns_csi</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">nsid</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">csi</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">xnvme_spec_idfy</span> <span class="o">*</span><span class="n">dbuf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xnvme_req</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Submit and wait for completion of an NVMe Get Log Page command</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> * @param lid Log Page Identifier for the log to retrieve entries for</span>
<span class="cm"> * @param lsp Log Specific Field for the log to retrieve entries for</span>
<span class="cm"> * @param lpo_nbytes Log page Offset in BYTES</span>
<span class="cm"> * @param nsid Namespace Identifier</span>
<span class="cm"> * @param rae Retain Asynchronous Event, 0=Clear, 1=Retain</span>
<span class="cm"> * @param dbuf Buffer allocated with `xnvme_buf_alloc`</span>
<span class="cm"> * @param dbuf_nbytes Number of BYTES to write from log-page to buf</span>
<span class="cm"> * @param req Pointer to structure for NVMe completion</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, 0 is returned. On error, negative `errno` is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_cmd_log</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">lid</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">lsp</span><span class="p">,</span>
	      <span class="kt">uint64_t</span> <span class="n">lpo_nbytes</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">nsid</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">rae</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dbuf</span><span class="p">,</span>
	      <span class="kt">uint32_t</span> <span class="n">dbuf_nbytes</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xnvme_req</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Submit and wait for completion of an NVMe Get Features (gfeat) command</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> * @param nsid Namespace identifier</span>
<span class="cm"> * @param fid Feature identifier</span>
<span class="cm"> * @param sel Select which value of the feature to select, that is, one of</span>
<span class="cm"> * current/default/saved/supported</span>
<span class="cm"> * @param dbuf pointer to data-payload, use if required for the given `fid`</span>
<span class="cm"> * @param dbuf_nbytes size of data-payload in bytes</span>
<span class="cm"> * @param req Pointer to structure for NVMe completion</span>
<span class="cm"> *</span>
<span class="cm"> * @return</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_cmd_gfeat</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">nsid</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">fid</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">sel</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">dbuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">dbuf_nbytes</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xnvme_req</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Submit and wait for completion of an NVMe Set Feature (sfeat) command</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> * @param nsid Namespace identifier</span>
<span class="cm"> * @param fid Feature identifier (see NVMe 1.3; Figure 84)</span>
<span class="cm"> * @param feat Structure defining feature attributes</span>
<span class="cm"> * @param save</span>
<span class="cm"> * @param dbuf pointer to data-payload</span>
<span class="cm"> * @param dbuf_nbytes size of the data-payload in bytes</span>
<span class="cm"> * @param req Pointer to structure for NVMe completion</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, 0 is returned. On error, negative `errno` is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_cmd_sfeat</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">nsid</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">fid</span><span class="p">,</span>
		<span class="kt">uint32_t</span> <span class="n">feat</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">save</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dbuf</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">dbuf_nbytes</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xnvme_req</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Submit and wait for completion of an NVMe Format NVM command</span>
<span class="cm"> *</span>
<span class="cm"> * TODO: consider timeout, reset, and need for library/dev re-initialization</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> * @param nsid Namespace identifier</span>
<span class="cm"> * @param lbaf The LBA format to format the Namespace with</span>
<span class="cm"> * @param zf Zone Format</span>
<span class="cm"> * @param mset Metadata Settings</span>
<span class="cm"> * @param ses Secure erase settings; 0x0: No Secure Erase, 0x1: User Data erase,</span>
<span class="cm"> * 0x2: Cryptographic Erase</span>
<span class="cm"> * @param pil Protection information location; 0x0: last eight bytes of</span>
<span class="cm"> * metadata, 0x1: first eight bytes of metadata</span>
<span class="cm"> * @param pi Protection information; 0x0: Disabled, 0x1: Enabled(Type1), 0x2:</span>
<span class="cm"> * Enabled(Type2), 0x3: Enabled(Type3)</span>
<span class="cm"> * @param req Pointer to structure for NVMe completion</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, 0 is returned. On error, negative `errno` is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_cmd_format</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">nsid</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">lbaf</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">zf</span><span class="p">,</span>
		 <span class="kt">uint8_t</span> <span class="n">mset</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">ses</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">pi</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">pil</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">xnvme_req</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Submit and wait for completion of an Sanitize command</span>
<span class="cm"> *</span>
<span class="cm"> * @todo consider timeout, reset, and need for library/dev re-initialization</span>
<span class="cm"> *</span>
<span class="cm"> * @note Success of this function only means that the sanitize *command*</span>
<span class="cm"> * succeeded and that the sanitize *operation* has started.</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> * @param sanact Sanitize action; 0x1: Exit failure mode, 0x2: Block Erase, 0x3</span>
<span class="cm"> * Overwrite, 0x4 Crypto Erase</span>
<span class="cm"> * @param ause: Allow Unrestricted Sanitize Exit; 0x0: Restricted Mode, 0x1:</span>
<span class="cm"> * Unrestricted Mode</span>
<span class="cm"> * @param ovrpat Overwrite Pattern; 32-bit pattern used by the Overwrite action</span>
<span class="cm"> * @param owpass Overwrite pass Count, how many times the media is to be</span>
<span class="cm"> * overwritten; 0x0: 15 overwrite passes</span>
<span class="cm"> * @param oipbp Overwrite invert pattern between passes; 0x0: Disabled, 0x1:</span>
<span class="cm"> * Enabled</span>
<span class="cm"> * @param nodas No Deallocate After Sanitize; 0x0: Attempt to deallocate; 0x1 Do</span>
<span class="cm"> * not attempt to deallocate</span>
<span class="cm"> * @param req Pointer to structure for NVMe completion</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, 0 is returned. On error, negative `errno` is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_cmd_sanitize</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">sanact</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">ause</span><span class="p">,</span>
		   <span class="kt">uint32_t</span> <span class="n">ovrpat</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">owpass</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">oipbp</span><span class="p">,</span>
		   <span class="kt">uint8_t</span> <span class="n">nodas</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xnvme_req</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Submit, and optionally wait for completion of, a NVMe Write</span>
<span class="cm"> *</span>
<span class="cm"> * @see xnvme_cmd_opts</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> * @param nsid Namespace Identifier</span>
<span class="cm"> * @param slba The LBA to start the write at</span>
<span class="cm"> * @param nlb Number of LBAs to be written. NOTE: nlb is a zero-based value</span>
<span class="cm"> * @param dbuf Pointer to buffer; Payload as indicated by &#39;opts&#39;</span>
<span class="cm"> * @param mbuf Pointer to buffer; Payload as indicated by &#39;opts&#39;</span>
<span class="cm"> * @param opts command options, see ::xnvme_cmd_opts</span>
<span class="cm"> * @param req Pointer to structure for NVMe completion and async. context</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, 0 is returned. On error, negative `errno` is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_cmd_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">nsid</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">slba</span><span class="p">,</span>
		<span class="kt">uint16_t</span> <span class="n">nlb</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dbuf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mbuf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">xnvme_req</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Submit, and optionally wait for completion of, a NVMe Read</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> * @param nsid Namespace Identifier</span>
<span class="cm"> * @param slba The LBA to start reading from</span>
<span class="cm"> * @param nlb The number of LBAs to read. NOTE: nlb is a zero-based value</span>
<span class="cm"> * @param dbuf Pointer to data-payload</span>
<span class="cm"> * @param mbuf Pointer to meta-payload</span>
<span class="cm"> * @param opts command options, see ::xnvme_cmd_opts</span>
<span class="cm"> * @param req Pointer to structure for NVMe completion and async. context</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, 0 is returned. On error, negative `errno` is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_cmd_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">nsid</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">slba</span><span class="p">,</span>
	       <span class="kt">uint16_t</span> <span class="n">nlb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dbuf</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mbuf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">xnvme_req</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Creates a handle to given device identifier</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev_uri File path &quot;/dev/nvme0n1&quot; or &quot;pci://0000:04.01&quot;</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, a handle to the device. On error, NULL is returned and</span>
<span class="cm"> * `errno` set to indicate the error.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span>
<span class="nf">xnvme_dev_open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_uri</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Creates a handle to given device path</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev_uri Identifier of the device to open e.g. &quot;/dev/nvme0n1&quot;</span>
<span class="cm"> * @param opts options for opening device</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, a handle to the device. On error, NULL is returned and</span>
<span class="cm"> * `errno` set to indicate the error.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span>
<span class="nf">xnvme_dev_openf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_uri</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Destroys device-handle</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">xnvme_dev_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Returns the geometry of the given device</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> *</span>
<span class="cm"> * @return The geometry (struct xnvme_geo) of given device handle</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_geo</span> <span class="o">*</span>
<span class="nf">xnvme_dev_get_geo</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Returns the NVMe identify controller structure associated with the given</span>
<span class="cm"> * device</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, pointer to namespace structure. On error, NULL is</span>
<span class="cm"> * returned and `errno` is set to indicate the error</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_spec_idfy_ctrlr</span> <span class="o">*</span>
<span class="nf">xnvme_dev_get_ctrlr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Returns the NVMe identify controller structure specific to the Command Set</span>
<span class="cm"> * and Namespace associated with the given device</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, pointer to namespace structure. On error, NULL is</span>
<span class="cm"> * returned and `errno` is set to indicate the error</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_spec_idfy_ctrlr</span> <span class="o">*</span>
<span class="nf">xnvme_dev_get_ctrlr_css</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Returns the NVMe identify namespace structure associated with the given</span>
<span class="cm"> * device</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, pointer to namespace structure. On error, NULL is</span>
<span class="cm"> * returned and `errno` is set to indicate the error</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_spec_idfy_ns</span> <span class="o">*</span>
<span class="nf">xnvme_dev_get_ns</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Returns the NVMe identify namespace structure specific to the Command Set and</span>
<span class="cm"> * Namespace associated with the given device</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, pointer to namespace structure. On error, NULL is</span>
<span class="cm"> * returned and `errno` is set to indicate the error</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_spec_idfy_ns</span> <span class="o">*</span>
<span class="nf">xnvme_dev_get_ns_css</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Returns the NVMe namespace identifier associated with the given `dev`</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, NVMe namespace identifier is returned</span>
<span class="cm"> */</span>
<span class="kt">uint32_t</span>
<span class="nf">xnvme_dev_get_nsid</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Returns the NVMe Command Set Identifier associated with the given `dev`</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, NVMe Command Set Identifier is returned</span>
<span class="cm"> */</span>
<span class="kt">uint8_t</span>
<span class="nf">xnvme_dev_get_csi</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Returns the internal backend state of the given `dev`</span>
<span class="cm"> *</span>
<span class="cm"> * @param dev Device handle obtained with xnvme_dev_open() / xnvme_dev_openf()</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the internal backend state is returned.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">xnvme_dev_get_be_state</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Returns the sector-shift-width of the device, that is, the value used for</span>
<span class="cm"> * converting block-device offset to lba, and vice-versa</span>
<span class="cm"> *</span>
<span class="cm"> * lba = ofz &gt;&gt; ssw</span>
<span class="cm"> * ofz = lba &lt;&lt; ssw</span>
<span class="cm"> *</span>
<span class="cm"> * @return On success, the ssw is returned.</span>
<span class="cm"> */</span>
<span class="kt">uint64_t</span> <span class="nf">xnvme_dev_get_ssw</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cp">#ifdef __cplusplus</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* __LIBXNVME_H */</span><span class="cp"></span>
</pre></div>
</div>
</div>
<div class="section" id="libxnvme-spec-h">
<h2>libxnvme_spec.h<a class="headerlink" href="#libxnvme-spec-h" title="Permalink to this headline">¶</a></h2>
<p>Definitions from the NVMe spec, along with declarations of associated helper
functions.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * libxnvme_spec - NVMe structs, enum, values and helper function declarations</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) Simon A. F. Lund &lt;simon.lund@samsung.com&gt;</span>
<span class="cm"> * Copyright (C) Klaus B. A. Jensen &lt;k.jensen@samsung.com&gt;</span>
<span class="cm"> * SPDX-License-Identifier: Apache-2.0</span>
<span class="cm"> *</span>
<span class="cm"> * @headerfile libxnvme_spec.h</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __LIBXNVME_SPEC_H</span>
<span class="cp">#define __LIBXNVME_SPEC_H</span>

<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;libxnvme_util.h&gt;</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * NVMe Command Completion Status field</span>
<span class="cm"> *</span>
<span class="cm"> * @struct xnvme_spec_status</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_spec_status</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint16_t</span> <span class="nl">p</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">///&lt; Phase tag</span>
			<span class="kt">uint16_t</span> <span class="nl">sc</span>	<span class="p">:</span> <span class="mi">8</span><span class="p">;</span>	<span class="c1">///&lt; Status codes</span>
			<span class="kt">uint16_t</span> <span class="nl">sct</span>	<span class="p">:</span> <span class="mi">3</span><span class="p">;</span>	<span class="c1">///&lt; Status code type</span>
			<span class="kt">uint16_t</span> <span class="nl">rsvd2</span>	<span class="p">:</span> <span class="mi">2</span><span class="p">;</span>
			<span class="kt">uint16_t</span> <span class="nl">m</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">///&lt; More</span>
			<span class="kt">uint16_t</span> <span class="nl">dnr</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">///&lt; Do not retry</span>
		<span class="p">};</span>
		<span class="kt">uint16_t</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_spec_status</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * Completion Queue Entry</span>
<span class="cm"> *</span>
<span class="cm"> * @struct xnvme_spec_cpl</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_spec_cpl</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="cm">/* dword 0 */</span>
			<span class="kt">uint32_t</span>	<span class="n">cdw0</span><span class="p">;</span>	<span class="c1">///&lt; command-specific</span>

			<span class="cm">/* dword 1 */</span>
			<span class="kt">uint32_t</span>	<span class="n">rsvd1</span><span class="p">;</span>
		<span class="p">};</span>

		<span class="kt">uint64_t</span> <span class="n">result</span><span class="p">;</span>	<span class="cm">/* Combined result of cdw 0 and cdw 1 */</span>
	<span class="p">};</span>

	<span class="cm">/* dword 2 */</span>
	<span class="kt">uint16_t</span>		<span class="n">sqhd</span><span class="p">;</span>	<span class="c1">///&lt; submission queue head pointer</span>
	<span class="kt">uint16_t</span>		<span class="n">sqid</span><span class="p">;</span>	<span class="c1">///&lt; submission queue identifier</span>

	<span class="cm">/* dword 3 */</span>
	<span class="kt">uint16_t</span>		<span class="n">cid</span><span class="p">;</span>	<span class="c1">///&lt; command identifier</span>
	<span class="k">struct</span> <span class="n">xnvme_spec_status</span>	<span class="n">status</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_spec_cpl</span><span class="p">)</span> <span class="o">==</span> <span class="mi">16</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * NVMe get-log-page entry for error information</span>
<span class="cm"> *</span>
<span class="cm"> * NVMe 1.4: Figure 194</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: using __attribute__((packed))__ as GCC does not like &quot;uint16_t ct&quot;</span>
<span class="cm"> * for some reason. Without the packing it becomes 2 bytes larger</span>
<span class="cm"> *</span>
<span class="cm"> * @struct xnvme_spec_log_health_entry</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">xnvme_spec_log_health_entry</span> <span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">crit_warn</span><span class="p">;</span>		<span class="c1">///&lt; Critical Warning</span>
	<span class="kt">uint16_t</span> <span class="n">comp_temp</span><span class="p">;</span>		<span class="c1">///&lt; Composite Temperature (Temp.)</span>
	<span class="kt">uint8_t</span> <span class="n">avail_spare</span><span class="p">;</span>		<span class="c1">///&lt; Available Spare (pct)</span>
	<span class="kt">uint8_t</span> <span class="n">avail_spare_thresh</span><span class="p">;</span>	<span class="c1">///&lt; Available Spare Threshold (pct)</span>
	<span class="kt">uint8_t</span> <span class="n">pct_used</span><span class="p">;</span>		<span class="c1">///&lt; Percentage used (pct), can exceed 100</span>
	<span class="kt">uint8_t</span> <span class="n">eg_crit_warn_sum</span><span class="p">;</span>	<span class="c1">///&lt; Endurance Group Critical Warning Summary</span>
	<span class="kt">uint8_t</span> <span class="n">rsvd8</span><span class="p">[</span><span class="mi">25</span><span class="p">];</span>

	<span class="kt">uint8_t</span> <span class="n">data_units_read</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="c1">///&lt; Data Units Read</span>
	<span class="kt">uint8_t</span> <span class="n">data_units_written</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="c1">///&lt; Data Units Written</span>

	<span class="kt">uint8_t</span> <span class="n">host_read_cmds</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="c1">///&lt; Host Read Commands</span>
	<span class="kt">uint8_t</span> <span class="n">host_write_cmds</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="c1">///&lt; Host Write Commands</span>

	<span class="kt">uint8_t</span> <span class="n">ctrlr_busy_time</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="c1">///&lt; Controller Busy Time</span>
	<span class="kt">uint8_t</span> <span class="n">pwr_cycles</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>		<span class="c1">///&lt; Power Cycles</span>
	<span class="kt">uint8_t</span> <span class="n">pwr_on_hours</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="c1">///&lt; Power On Hours</span>
	<span class="kt">uint8_t</span> <span class="n">unsafe_shutdowns</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="c1">///&lt; Unsafe Shutdowns</span>
	<span class="kt">uint8_t</span> <span class="n">mdi_errs</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>		<span class="c1">///&lt; Media and Data Integrity Errors</span>
	<span class="kt">uint8_t</span> <span class="n">nr_err_logs</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="c1">///&lt; Nr. of Error Information Log Entries (life)</span>

	<span class="kt">uint32_t</span> <span class="n">warn_comp_temp_time</span><span class="p">;</span>	<span class="c1">///&lt; Warning Composite Temp. Time</span>
	<span class="kt">uint32_t</span> <span class="n">crit_comp_temp_time</span><span class="p">;</span>	<span class="c1">///&lt; Critical Composite Temp. Time</span>
	<span class="kt">uint16_t</span> <span class="n">temp_sens</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>	<span class="c1">///&lt; Temp. Sensor Temp. 1-8</span>
	<span class="kt">uint32_t</span> <span class="n">tmt1tc</span><span class="p">;</span>	<span class="c1">///&lt; Thermal Management Temp. 1 Trans. Count</span>
	<span class="kt">uint32_t</span> <span class="n">tmt2tc</span><span class="p">;</span>	<span class="c1">///&lt; Thermal Management Temp. 2 Trans. Count</span>
	<span class="kt">uint32_t</span> <span class="n">tttmt1</span><span class="p">;</span>	<span class="c1">///&lt; Total Time for Thermal Mgmt. Temp. 1</span>
	<span class="kt">uint32_t</span> <span class="n">tttmt2</span><span class="p">;</span>	<span class="c1">///&lt; Total Time for Thermal Mgmt. Temp. 2</span>
	<span class="kt">uint8_t</span> <span class="n">rsvd</span><span class="p">[</span><span class="mi">280</span><span class="p">];</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_spec_log_health_entry</span><span class="p">)</span> <span class="o">==</span> <span class="mi">512</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given :;xnvme_spec_log_health_entry to the given output stream</span>
<span class="cm"> *</span>
<span class="cm"> * @param stream output stream used for printing</span>
<span class="cm"> * @param log pointer to the structure to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="n">xnvme_spec_log_health_fpr</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_spec_log_health_entry</span> <span class="o">*</span><span class="n">log</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given :;xnvme_spec_log_health_entry to stdout</span>
<span class="cm"> *</span>
<span class="cm"> * @param log</span>
<span class="cm"> * @param opts</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_spec_log_health_pr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_spec_log_health_entry</span> <span class="o">*</span><span class="n">log</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * NVMe get-log-page entry for error information</span>
<span class="cm"> *</span>
<span class="cm"> * NVMe 1.4 - Figure ?</span>
<span class="cm"> *</span>
<span class="cm"> * @struct xnvme_spec_log_erri_entry</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_spec_log_erri_entry</span> <span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">ecnt</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">sqid</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">cid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xnvme_spec_status</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">eloc</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">lba</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">nsid</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">ven_si</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">trtype</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">reserved30</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">uint64_t</span> <span class="n">cmd_si</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">trtype_si</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">reserved42</span><span class="p">[</span><span class="mi">22</span><span class="p">];</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_spec_log_erri_entry</span><span class="p">)</span> <span class="o">==</span> <span class="mi">64</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given :;xnvme_spec_log_erri_entry to stdout</span>
<span class="cm"> *</span>
<span class="cm"> * @param stream output stream used for printing</span>
<span class="cm"> * @param log</span>
<span class="cm"> * @param limit</span>
<span class="cm"> * @param opts</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="n">xnvme_spec_log_erri_fpr</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_spec_log_erri_entry</span> <span class="o">*</span><span class="n">log</span><span class="p">,</span> <span class="kt">int</span> <span class="n">limit</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given :;xnvme_spec_log_erri_entry to stdout</span>
<span class="cm"> *</span>
<span class="cm"> * @param log</span>
<span class="cm"> * @param limit</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_spec_log_erri_pr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_spec_log_erri_entry</span> <span class="o">*</span><span class="n">log</span><span class="p">,</span> <span class="kt">int</span> <span class="n">limit</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Identifiers (lpi) for NVMe get-log-page</span>
<span class="cm"> *</span>
<span class="cm"> * NVMe 1.4 - Figure ?</span>
<span class="cm"> *</span>
<span class="cm"> * @enum xnvme_spec_log_lpi</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">xnvme_spec_log_lpi</span> <span class="p">{</span>
	<span class="n">XNVME_SPEC_LOG_RSVD</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>  <span class="c1">///&lt; XNVME_SPEC_LOG_RSVD</span>
	<span class="n">XNVME_SPEC_LOG_ERRI</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>	 <span class="c1">///&lt; XNVME_SPEC_LOG_ERRI</span>
	<span class="n">XNVME_SPEC_LOG_HEALTH</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>	 <span class="c1">///&lt; XNVME_SPEC_LOG_HEALTH</span>
	<span class="n">XNVME_SPEC_LOG_FW</span> <span class="o">=</span> <span class="mh">0x3</span><span class="p">,</span>		 <span class="c1">///&lt; XNVME_SPEC_LOG_FW</span>
	<span class="n">XNVME_SPEC_LOG_CHNS</span> <span class="o">=</span> <span class="mh">0x4</span><span class="p">,</span>	 <span class="c1">///&lt; XNVME_SPEC_LOG_CHNS</span>
	<span class="n">XNVME_SPEC_LOG_CSAE</span> <span class="o">=</span> <span class="mh">0x5</span><span class="p">,</span>	 <span class="c1">///&lt; XNVME_SPEC_LOG_CSAE</span>
	<span class="n">XNVME_SPEC_LOG_SELFTEST</span> <span class="o">=</span> <span class="mh">0x6</span><span class="p">,</span>	 <span class="c1">///&lt; XNVME_SPEC_LOG_SELFTEST</span>
	<span class="n">XNVME_SPEC_LOG_TELEHOST</span> <span class="o">=</span> <span class="mh">0x7</span><span class="p">,</span>	 <span class="c1">///&lt; XNVME_SPEC_LOG_TELEHOST</span>
	<span class="n">XNVME_SPEC_LOG_TELECTRLR</span> <span class="o">=</span> <span class="mh">0x8</span><span class="p">,</span>	 <span class="c1">///&lt; XNVME_SPEC_LOG_TELECTRLR</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * @enum xnvme_spec_idfy_cns</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">xnvme_spec_idfy_cns</span> <span class="p">{</span>
	<span class="n">XNVME_SPEC_IDFY_NS</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_IDFY_NS</span>
	<span class="n">XNVME_SPEC_IDFY_CTRLR</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_IDFY_CTRLR</span>
	<span class="n">XNVME_SPEC_IDFY_NSLIST</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_IDFY_NSLIST</span>
	<span class="n">XNVME_SPEC_IDFY_NSDSCR</span> <span class="o">=</span> <span class="mh">0x3</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_IDFY_NSDSCR</span>
	<span class="n">XNVME_SPEC_IDFY_SETL</span> <span class="o">=</span> <span class="mh">0x4</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_IDFY_SETL</span>

	<span class="n">XNVME_SPEC_IDFY_NS_IOCS</span> <span class="o">=</span> <span class="mh">0x05</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_IDFY_NS_IOCS</span>
	<span class="n">XNVME_SPEC_IDFY_CTRLR_IOCS</span> <span class="o">=</span> <span class="mh">0x6</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_IDFY_CTRLR_IOCS</span>
	<span class="n">XNVME_SPEC_IDFY_NSLIST_IOCS</span> <span class="o">=</span> <span class="mh">0x7</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_IDFY_NSLIST_IOCS</span>

	<span class="n">XNVME_SPEC_IDFY_NSLIST_ALLOC</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_IDFY_NSLIST_ALLOC</span>
	<span class="n">XNVME_SPEC_IDFY_NS_ALLOC</span> <span class="o">=</span> <span class="mh">0x11</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_IDFY_NS_ALLOC</span>
	<span class="n">XNVME_SPEC_IDFY_CTRLR_NS</span> <span class="o">=</span> <span class="mh">0x12</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_IDFY_CTRLR_NS</span>
	<span class="n">XNVME_SPEC_IDFY_CTRLR_SUB</span> <span class="o">=</span> <span class="mh">0x13</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_IDFY_CTRLR_SUB</span>
	<span class="n">XNVME_SPEC_IDFY_CTRLR_PRI</span> <span class="o">=</span> <span class="mh">0x14</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_IDFY_CTRLR_PRI</span>
	<span class="n">XNVME_SPEC_IDFY_CTRLR_SEC</span> <span class="o">=</span> <span class="mh">0x15</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_IDFY_CTRLR_SEC</span>
	<span class="n">XNVME_SPEC_IDFY_NSGRAN</span> <span class="o">=</span> <span class="mh">0x16</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_IDFY_NSGRAN</span>
	<span class="n">XNVME_SPEC_IDFY_UUIDL</span> <span class="o">=</span> <span class="mh">0x17</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_IDFY_UUIDL</span>

	<span class="n">XNVME_SPEC_IDFY_NSLIST_ALLOC_IOCS</span> <span class="o">=</span> <span class="mh">0x1A</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_IDFY_NSLIST_ALLOC_IOCS</span>
	<span class="n">XNVME_SPEC_IDFY_NS_ALLOC_IOCS</span> <span class="o">=</span> <span class="mh">0x1B</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_IDFY_NS_ALLOC_IOCS</span>
	<span class="n">XNVME_SPEC_IDFY_IOCS</span> <span class="o">=</span> <span class="mh">0x1C</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_IDFY_IOCS</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * @struct xnvme_spec_lbaf</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_spec_lbaf</span> <span class="p">{</span>
	<span class="kt">uint16_t</span> <span class="n">ms</span><span class="p">;</span>	<span class="c1">///&lt; metadata size</span>
	<span class="kt">uint8_t</span>  <span class="n">ds</span><span class="p">;</span>	<span class="c1">///&lt; lba data size</span>
	<span class="kt">uint8_t</span>  <span class="nl">rp</span><span class="p">:</span> <span class="mi">2</span><span class="p">;</span>	<span class="c1">///&lt; relative performance</span>
	<span class="kt">uint8_t</span>	 <span class="nl">rsvd</span> <span class="p">:</span> <span class="mi">6</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_spec_lbaf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * Command Set Identifiers</span>
<span class="cm"> *</span>
<span class="cm"> * @see Specification Section 5.15.2.1, figure X1</span>
<span class="cm"> *</span>
<span class="cm"> * @enum xnvme_spec_csi</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">xnvme_spec_csi</span> <span class="p">{</span>
	<span class="n">XNVME_SPEC_CSI_LBLK</span>	<span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>	<span class="c1">///&lt; XNVME_SPEC_CSI_LBLK</span>
	<span class="n">XNVME_SPEC_CSI_ZONED</span>	<span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>	<span class="c1">///&lt; XNVME_SPEC_CSI_ZONED</span>

	<span class="n">XNVME_SPEC_CSI_NOCHECK</span>	<span class="o">=</span> <span class="mh">0xFF</span><span class="p">,</span>	<span class="c1">///&lt; XNVME_SPEC_CSI_NOCHECK</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Produces a string representation of the given ::xnvme_spec_csi</span>
<span class="cm"> *</span>
<span class="cm"> * @param nst the enum value to produce a string representation of</span>
<span class="cm"> * @return On success, a string representation is returned. On error, the string</span>
<span class="cm"> * &quot;XNVME_SPEC_CSI_ENOSYS&quot; is returned.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span>
<span class="nf">xnvme_spec_csi_str</span><span class="p">(</span><span class="k">enum</span> <span class="n">xnvme_spec_csi</span> <span class="n">csi</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Representation of NVMe completion result Identify Namespace</span>
<span class="cm"> *</span>
<span class="cm"> * That is, for opcode XNVME_SPEC_OPC_IDFY(0x06) with XNVME_SPEC_IDFY_NS(0x0)</span>
<span class="cm"> *</span>
<span class="cm"> * @struct xnvme_spec_idfy_ns</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_spec_idfy_ns</span> <span class="p">{</span>
	<span class="kt">uint64_t</span>	<span class="n">nsze</span><span class="p">;</span> <span class="c1">///&lt; namespace size</span>
	<span class="kt">uint64_t</span>	<span class="n">ncap</span><span class="p">;</span> <span class="c1">///&lt; namespace capacity</span>
	<span class="kt">uint64_t</span>	<span class="n">nuse</span><span class="p">;</span> <span class="c1">///&lt; namespace utilization</span>

	<span class="cm">/** namespace features */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">uint8_t</span>	<span class="nl">thin_prov</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">///&lt; thin provisioning</span>
		<span class="kt">uint8_t</span>	<span class="nl">ns_atomic_write_unit</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">///&lt; NAWUN, NAWUPF, and NACWU</span>
		<span class="kt">uint8_t</span>	<span class="nl">dealloc_or_unwritten_error</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="kt">uint8_t</span>	<span class="nl">guid_never_reused</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">////&lt; Non-zero NGUID and EUI64</span>

		<span class="kt">uint8_t</span>	<span class="nl">reserved1</span> <span class="p">:</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">nsfeat</span><span class="p">;</span>

	<span class="kt">uint8_t</span>		<span class="n">nlbaf</span><span class="p">;</span> <span class="c1">///&lt; number of lba formats</span>

	<span class="cm">/** formatted lba size */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">uint8_t</span>	<span class="nl">format</span>    <span class="p">:</span> <span class="mi">4</span><span class="p">;</span>
		<span class="kt">uint8_t</span>	<span class="nl">extended</span>  <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="kt">uint8_t</span>	<span class="nl">reserved2</span> <span class="p">:</span> <span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">flbas</span><span class="p">;</span>

	<span class="cm">/** metadata capabilities */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/** metadata can be transferred as part of data prp list */</span>
		<span class="kt">uint8_t</span>		<span class="nl">extended</span>  <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/** metadata can be transferred with separate metadata pointer */</span>
		<span class="kt">uint8_t</span>		<span class="nl">pointer</span>   <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/** reserved */</span>
		<span class="kt">uint8_t</span>		<span class="nl">reserved3</span> <span class="p">:</span> <span class="mi">6</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">mc</span><span class="p">;</span>

	<span class="cm">/** end-to-end data protection capabilities */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="cm">/** protection information type 1 */</span>
			<span class="kt">uint8_t</span>		<span class="nl">pit1</span>     <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/** protection information type 2 */</span>
			<span class="kt">uint8_t</span>		<span class="nl">pit2</span>     <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/** protection information type 3 */</span>
			<span class="kt">uint8_t</span>		<span class="nl">pit3</span>     <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/** first eight bytes of metadata */</span>
			<span class="kt">uint8_t</span>		<span class="nl">md_start</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/** last eight bytes of metadata */</span>
			<span class="kt">uint8_t</span>		<span class="nl">md_end</span>   <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">};</span>
		<span class="kt">uint8_t</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">dpc</span><span class="p">;</span>

	<span class="cm">/** end-to-end data protection type settings */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="cm">/** protection information type */</span>
			<span class="kt">uint8_t</span>		<span class="nl">pit</span>       <span class="p">:</span> <span class="mi">3</span><span class="p">;</span>

			<span class="cm">/** 1 == protection info transferred at start of metadata */</span>
			<span class="cm">/** 0 == protection info transferred at end of metadata */</span>
			<span class="kt">uint8_t</span>		<span class="nl">md_start</span>  <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

			<span class="kt">uint8_t</span>		<span class="nl">reserved4</span> <span class="p">:</span> <span class="mi">4</span><span class="p">;</span>
		<span class="p">};</span>
		<span class="kt">uint8_t</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">dps</span><span class="p">;</span>

	<span class="cm">/** namespace multi-path I/O and namespace sharing capabilities */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">uint8_t</span>		<span class="nl">can_share</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="kt">uint8_t</span>		<span class="nl">reserved</span> <span class="p">:</span> <span class="mi">7</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">nmic</span><span class="p">;</span>

	<span class="cm">/** reservation capabilities */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="cm">/** supports persist through power loss */</span>
			<span class="kt">uint8_t</span>		<span class="nl">persist</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/** supports write exclusive */</span>
			<span class="kt">uint8_t</span>		<span class="nl">write_exclusive</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/** supports exclusive access */</span>
			<span class="kt">uint8_t</span>		<span class="nl">exclusive_access</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/** supports write exclusive - registrants only */</span>
			<span class="kt">uint8_t</span>		<span class="nl">write_exclusive_reg_only</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/** supports exclusive access - registrants only */</span>
			<span class="kt">uint8_t</span>		<span class="nl">exclusive_access_reg_only</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/** supports write exclusive - all registrants */</span>
			<span class="kt">uint8_t</span>		<span class="nl">write_exclusive_all_reg</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/** supports exclusive access - all registrants */</span>
			<span class="kt">uint8_t</span>		<span class="nl">exclusive_access_all_reg</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/** supports ignore existing key */</span>
			<span class="kt">uint8_t</span>		<span class="nl">ignore_existing_key</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">};</span>
		<span class="kt">uint8_t</span>	 <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">nsrescap</span><span class="p">;</span>

	<span class="cm">/** format progress indicator */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint8_t</span>		<span class="nl">percentage_remaining</span> <span class="p">:</span> <span class="mi">7</span><span class="p">;</span>
			<span class="kt">uint8_t</span>		<span class="nl">fpi_supported</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">};</span>
		<span class="kt">uint8_t</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">fpi</span><span class="p">;</span>

	<span class="cm">/** deallocate logical features */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="cm">/**</span>
<span class="cm">			 * Value read from deallocated blocks</span>
<span class="cm">			 *</span>
<span class="cm">			 * 000b = not reported</span>
<span class="cm">			 * 001b = all bytes 0x00</span>
<span class="cm">			 * 010b = all bytes 0xFF</span>
<span class="cm">			 *</span>
<span class="cm">			 */</span>
			<span class="kt">uint8_t</span> <span class="nl">read_value</span> <span class="p">:</span> <span class="mi">3</span><span class="p">;</span>

			<span class="cm">/** Supports Deallocate bit in Write Zeroes */</span>
			<span class="kt">uint8_t</span> <span class="nl">write_zero_deallocate</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/**</span>
<span class="cm">			 * Guard field behavior for deallocated logical blocks</span>
<span class="cm">			 * 0: contains 0xFFFF</span>
<span class="cm">			 * 1: contains CRC for read value</span>
<span class="cm">			 */</span>
			<span class="kt">uint8_t</span> <span class="nl">guard_value</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

			<span class="kt">uint8_t</span> <span class="nl">reserved</span> <span class="p">:</span> <span class="mi">3</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">bits</span><span class="p">;</span>

		<span class="kt">uint8_t</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">dlfeat</span><span class="p">;</span>

	<span class="cm">/** namespace atomic write unit normal */</span>
	<span class="kt">uint16_t</span> <span class="n">nawun</span><span class="p">;</span>

	<span class="cm">/** namespace atomic write unit power fail */</span>
	<span class="kt">uint16_t</span> <span class="n">nawupf</span><span class="p">;</span>

	<span class="cm">/** namespace atomic compare &amp; write unit */</span>
	<span class="kt">uint16_t</span> <span class="n">nacwu</span><span class="p">;</span>

	<span class="cm">/** namespace atomic boundary size normal */</span>
	<span class="kt">uint16_t</span> <span class="n">nabsn</span><span class="p">;</span>

	<span class="cm">/** namespace atomic boundary offset */</span>
	<span class="kt">uint16_t</span> <span class="n">nabo</span><span class="p">;</span>

	<span class="cm">/** namespace atomic boundary size power fail */</span>
	<span class="kt">uint16_t</span> <span class="n">nabspf</span><span class="p">;</span>

	<span class="cm">/** namespace optimal I/O boundary in logical blocks */</span>
	<span class="kt">uint16_t</span> <span class="n">noiob</span><span class="p">;</span>

	<span class="kt">uint64_t</span> <span class="n">nvmcap</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="c1">///&lt; NVM Capacity</span>

	<span class="kt">uint8_t</span> <span class="n">reserved64</span><span class="p">[</span><span class="mi">40</span><span class="p">];</span>

	<span class="cm">/** namespace globally unique identifier */</span>
	<span class="kt">uint8_t</span> <span class="n">nguid</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

	<span class="cm">/** IEEE extended unique identifier */</span>
	<span class="kt">uint64_t</span> <span class="n">eui64</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">xnvme_spec_lbaf</span>	<span class="n">lbaf</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="c1">/// LBA format support</span>

	<span class="kt">uint8_t</span> <span class="n">rsvd3776</span><span class="p">[</span><span class="mi">3648</span><span class="p">];</span>

	<span class="kt">uint8_t</span> <span class="n">vendor_specific</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_spec_idfy_ns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4096</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given :;xnvme_spec_idfy_ns to the given output stream</span>
<span class="cm"> *</span>
<span class="cm"> * @param stream output stream used for printing</span>
<span class="cm"> * @param idfy pointer to structure to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="n">xnvme_spec_idfy_ns_fpr</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_spec_idfy_ns</span> <span class="o">*</span><span class="n">idfy</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given :;xnvme_spec_idfy_ns to stdout</span>
<span class="cm"> *</span>
<span class="cm"> * @param idfy pointer to structure to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_spec_idfy_ns_pr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_spec_idfy_ns</span> <span class="o">*</span><span class="n">idfy</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cp">#define XNVME_SPEC_CTRLR_SN_LEN 20</span>
<span class="cp">#define XNVME_SPEC_CTRLR_MN_LEN 40</span>
<span class="cp">#define XNVME_SPEC_CTRLR_FR_LEN 8</span>

<span class="cm">/**</span>
<span class="cm"> * @struct xnvme_spec_power_state</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_spec_power_state</span> <span class="p">{</span>
	<span class="kt">uint16_t</span> <span class="n">mp</span><span class="p">;</span>			<span class="cm">/* bits 15:00: maximum power */</span>

	<span class="kt">uint8_t</span> <span class="n">reserved1</span><span class="p">;</span>

	<span class="kt">uint8_t</span> <span class="nl">mps</span>		<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* bit 24: max power scale */</span>
	<span class="kt">uint8_t</span> <span class="nl">nops</span>		<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* bit 25: non-operational state */</span>
	<span class="kt">uint8_t</span> <span class="nl">reserved2</span>	<span class="p">:</span> <span class="mi">6</span><span class="p">;</span>

	<span class="kt">uint32_t</span> <span class="n">enlat</span><span class="p">;</span>			<span class="cm">/* bits 63:32: entry latency in microseconds */</span>
	<span class="kt">uint32_t</span> <span class="n">exlat</span><span class="p">;</span>			<span class="cm">/* bits 95:64: exit latency in microseconds */</span>

	<span class="kt">uint8_t</span> <span class="nl">rrt</span>		<span class="p">:</span> <span class="mi">5</span><span class="p">;</span>	<span class="cm">/* bits 100:96: relative read throughput */</span>
	<span class="kt">uint8_t</span> <span class="nl">reserved3</span>	<span class="p">:</span> <span class="mi">3</span><span class="p">;</span>

	<span class="kt">uint8_t</span> <span class="nl">rrl</span>		<span class="p">:</span> <span class="mi">5</span><span class="p">;</span>	<span class="cm">/* bits 108:104: relative read latency */</span>
	<span class="kt">uint8_t</span> <span class="nl">reserved4</span>	<span class="p">:</span> <span class="mi">3</span><span class="p">;</span>

	<span class="kt">uint8_t</span> <span class="nl">rwt</span>		<span class="p">:</span> <span class="mi">5</span><span class="p">;</span>	<span class="cm">/* bits 116:112: relative write throughput */</span>
	<span class="kt">uint8_t</span> <span class="nl">reserved5</span>	<span class="p">:</span> <span class="mi">3</span><span class="p">;</span>

	<span class="kt">uint8_t</span> <span class="nl">rwl</span>		<span class="p">:</span> <span class="mi">5</span><span class="p">;</span>	<span class="cm">/* bits 124:120: relative write latency */</span>
	<span class="kt">uint8_t</span> <span class="nl">reserved6</span>	<span class="p">:</span> <span class="mi">3</span><span class="p">;</span>

	<span class="kt">uint8_t</span> <span class="n">reserved7</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_spec_power_state</span><span class="p">)</span> <span class="o">==</span> <span class="mi">32</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * @struct xnvme_spec_vs_register</span>
<span class="cm"> */</span>
<span class="k">union</span> <span class="n">xnvme_spec_vs_register</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">uint32_t</span> <span class="nl">ter</span> <span class="p">:</span> <span class="mi">8</span><span class="p">;</span>	<span class="c1">///&lt; Tertiary version</span>
		<span class="kt">uint32_t</span> <span class="nl">mnr</span> <span class="p">:</span> <span class="mi">8</span><span class="p">;</span>	<span class="c1">///&lt; Indicated Minor Version</span>
		<span class="kt">uint32_t</span> <span class="nl">mjr</span> <span class="p">:</span> <span class="mi">16</span><span class="p">;</span>	<span class="c1">///&lt; Indicated Major Version</span>
	<span class="p">}</span> <span class="n">bits</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">xnvme_spec_vs_register</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * @struct xnvme_spec_idfy_ctrlr</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_spec_idfy_ctrlr</span> <span class="p">{</span>
	<span class="cm">/* bytes 0-255: controller capabilities and features */</span>

	<span class="kt">uint16_t</span> <span class="n">vid</span><span class="p">;</span>				<span class="c1">///&lt; PCI Vendor ID</span>
	<span class="kt">uint16_t</span> <span class="n">ssvid</span><span class="p">;</span>				<span class="c1">///&lt; PCI Subsystem Vendor ID</span>
	<span class="kt">int8_t</span> <span class="n">sn</span><span class="p">[</span><span class="n">XNVME_SPEC_CTRLR_SN_LEN</span><span class="p">];</span>	<span class="c1">///&lt; SerialNumber</span>
	<span class="kt">int8_t</span> <span class="n">mn</span><span class="p">[</span><span class="n">XNVME_SPEC_CTRLR_MN_LEN</span><span class="p">];</span>	<span class="c1">///&lt; Model Number</span>
	<span class="kt">uint8_t</span> <span class="n">fr</span><span class="p">[</span><span class="n">XNVME_SPEC_CTRLR_FR_LEN</span><span class="p">];</span>	<span class="c1">///&lt; Firmware Revision</span>
	<span class="kt">uint8_t</span> <span class="n">rab</span><span class="p">;</span>				<span class="c1">///&lt; Recomm. Arbitration Burst</span>
	<span class="kt">uint8_t</span> <span class="n">ieee</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>			<span class="c1">///&lt; IEEE OUI Identifier</span>

	<span class="cm">/** controller multi-path I/O and namespace sharing capabilities */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint8_t</span> <span class="nl">multi_port</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint8_t</span> <span class="nl">multi_host</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint8_t</span> <span class="nl">sr_iov</span>		<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint8_t</span> <span class="nl">reserved</span>	<span class="p">:</span> <span class="mi">5</span><span class="p">;</span>
		<span class="p">};</span>
		<span class="kt">uint8_t</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">cmic</span><span class="p">;</span>

	<span class="kt">uint8_t</span> <span class="n">mdts</span><span class="p">;</span>				<span class="c1">///&lt; Maximum Data Transfer Size</span>
	<span class="kt">uint16_t</span> <span class="n">cntlid</span><span class="p">;</span>			<span class="c1">///&lt; Controller ID</span>
	<span class="k">union</span> <span class="n">xnvme_spec_vs_register</span> <span class="n">ver</span><span class="p">;</span>		<span class="c1">///&lt; Version</span>

	<span class="kt">uint32_t</span> <span class="n">rtd3r</span><span class="p">;</span>				<span class="c1">///&lt; RTD3 Resume Latency</span>
	<span class="kt">uint32_t</span> <span class="n">rtd3e</span><span class="p">;</span>				<span class="c1">///&lt; RTD3 Resume Latency</span>

	<span class="cm">/** optional asynchronous events supported */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint32_t</span> <span class="nl">reserved1</span>		<span class="p">:</span> <span class="mi">8</span><span class="p">;</span>

			<span class="cm">/** Supports sending Namespace Attribute Notices. */</span>
			<span class="kt">uint32_t</span> <span class="nl">ns_attribute_notices</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/** Supports sending Firmware Activation Notices. */</span>
			<span class="kt">uint32_t</span> <span class="nl">fw_activation_notices</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

			<span class="kt">uint32_t</span> <span class="nl">reserved2</span>		<span class="p">:</span> <span class="mi">22</span><span class="p">;</span>
		<span class="p">};</span>
		<span class="kt">uint32_t</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">oaes</span><span class="p">;</span>

	<span class="cm">/** controller attributes */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="cm">/** Supports 128-bit host identifier */</span>
			<span class="kt">uint32_t</span> <span class="nl">host_id_exhid_supported</span><span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/** Supports non-operational power state permissive mode */</span>
			<span class="kt">uint32_t</span> <span class="nl">non_operational_power_state_permissive_mode</span><span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

			<span class="kt">uint32_t</span> <span class="nl">reserved</span><span class="p">:</span> <span class="mi">30</span><span class="p">;</span>
		<span class="p">};</span>
		<span class="kt">uint32_t</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ctratt</span><span class="p">;</span>

	<span class="kt">uint8_t</span> <span class="n">reserved_100</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>

	<span class="kt">uint8_t</span> <span class="n">fguid</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="c1">///&lt; FRU Globally Unique Ident.</span>

	<span class="kt">uint8_t</span> <span class="n">reserved_128</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>

	<span class="cm">/* bytes 256-511: admin command set attributes */</span>

	<span class="cm">/** optional admin command support */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="cm">/* supports security send/receive commands */</span>
			<span class="kt">uint16_t</span> <span class="nl">security</span>			<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/* supports format nvm command */</span>
			<span class="kt">uint16_t</span> <span class="nl">format</span>				<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/* supports firmware activate/download commands */</span>
			<span class="kt">uint16_t</span> <span class="nl">firmware</span>			<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/* supports ns manage/ns attach commands */</span>
			<span class="kt">uint16_t</span> <span class="nl">ns_manage</span>			<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint16_t</span> <span class="nl">device_self_test</span>		<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint16_t</span> <span class="nl">directives</span>			<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint16_t</span> <span class="nl">nvme_mi</span>			<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/** Supports SPDK_NVME_OPC_VIRTUALIZATION_MANAGEMENT */</span>
			<span class="kt">uint16_t</span> <span class="nl">virtualization_management</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/** Supports SPDK_NVME_OPC_DOORBELL_BUFFER_CONFIG */</span>
			<span class="kt">uint16_t</span> <span class="nl">doorbell_buffer_config</span>		<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint16_t</span> <span class="nl">oacs_rsvd</span>			<span class="p">:</span> <span class="mi">7</span><span class="p">;</span>
		<span class="p">};</span>
		<span class="kt">uint16_t</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">oacs</span><span class="p">;</span>

	<span class="cm">/** abort command limit */</span>
	<span class="kt">uint8_t</span> <span class="n">acl</span><span class="p">;</span>

	<span class="cm">/** asynchronous event request limit */</span>
	<span class="kt">uint8_t</span> <span class="n">aerl</span><span class="p">;</span>

	<span class="cm">/** firmware updates */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="cm">/* first slot is read-only */</span>
			<span class="kt">uint8_t</span> <span class="nl">slot1_ro</span>			<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/* number of firmware slots */</span>
			<span class="kt">uint8_t</span> <span class="nl">num_slots</span>			<span class="p">:</span> <span class="mi">3</span><span class="p">;</span>

			<span class="cm">/* support activation without reset */</span>
			<span class="kt">uint8_t</span> <span class="nl">activation_without_reset</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

			<span class="kt">uint8_t</span> <span class="nl">frmw_rsvd</span>			<span class="p">:</span> <span class="mi">3</span><span class="p">;</span>
		<span class="p">};</span>
		<span class="kt">uint8_t</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">frmw</span><span class="p">;</span>

	<span class="cm">/** Log Page Attributes */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="cm">/* per namespace smart/health log page */</span>
			<span class="kt">uint8_t</span> <span class="nl">ns_smart</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* command effects log page */</span>
			<span class="kt">uint8_t</span> <span class="nl">celp</span>		<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* extended data (32bit vs 12bit) for get log page */</span>
			<span class="kt">uint8_t</span> <span class="nl">edlp</span>		<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* telemetry log pages and notices */</span>
			<span class="kt">uint8_t</span> <span class="nl">telemetry</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* Persistent event log */</span>
			<span class="kt">uint8_t</span> <span class="nl">pel</span>		<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

			<span class="kt">uint8_t</span> <span class="nl">lpa_rsvd</span>	<span class="p">:</span> <span class="mi">3</span><span class="p">;</span>
		<span class="p">};</span>
		<span class="kt">uint8_t</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">lpa</span><span class="p">;</span>

	<span class="kt">uint8_t</span> <span class="n">elpe</span><span class="p">;</span>		<span class="c1">///&lt; Error Log Page Entries</span>
	<span class="kt">uint8_t</span> <span class="n">npss</span><span class="p">;</span>		<span class="c1">///&lt; Number of Power States Supported</span>

	<span class="cm">/** admin vendor specific command configuration */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="cm">/* admin vendor specific commands use disk format */</span>
			<span class="kt">uint8_t</span> <span class="nl">spec_format</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint8_t</span> <span class="nl">avscc_rsvd</span>	<span class="p">:</span> <span class="mi">7</span><span class="p">;</span>
		<span class="p">};</span>
		<span class="kt">uint8_t</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">avscc</span><span class="p">;</span>

	<span class="cm">/** autonomous power state transition attributes */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint8_t</span> <span class="nl">supported</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint8_t</span> <span class="nl">apsta_rsvd</span>	<span class="p">:</span> <span class="mi">7</span><span class="p">;</span>
		<span class="p">};</span>
		<span class="kt">uint8_t</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">apsta</span><span class="p">;</span>

	<span class="kt">uint16_t</span> <span class="n">wctemp</span><span class="p">;</span>	<span class="c1">///&lt; Warning Composite Temperature threshold</span>
	<span class="kt">uint16_t</span> <span class="n">cctemp</span><span class="p">;</span>	<span class="c1">///&lt; Critical Composite Temperature threshold</span>
	<span class="kt">uint16_t</span> <span class="n">mtfa</span><span class="p">;</span>		<span class="c1">///&lt; Maximum Time for Firmware Activation</span>
	<span class="kt">uint32_t</span> <span class="n">hmpre</span><span class="p">;</span>		<span class="c1">///&lt; Host Memory Buffer Preferred size</span>
	<span class="kt">uint32_t</span> <span class="n">hmmin</span><span class="p">;</span>		<span class="c1">///&lt; Host Memory Buffer Minimum size */</span>

	<span class="cm">/** total NVM capacity */</span>
	<span class="kt">uint64_t</span> <span class="n">tnvmcap</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="cm">/** unallocated NVM capacity */</span>
	<span class="kt">uint64_t</span> <span class="n">unvmcap</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="cm">/** replay protected memory block support */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint8_t</span>		<span class="nl">num_rpmb_units</span>	<span class="p">:</span> <span class="mi">3</span><span class="p">;</span>
			<span class="kt">uint8_t</span>		<span class="nl">auth_method</span>	<span class="p">:</span> <span class="mi">3</span><span class="p">;</span>
			<span class="kt">uint8_t</span>		<span class="nl">reserved1</span>	<span class="p">:</span> <span class="mi">2</span><span class="p">;</span>

			<span class="kt">uint8_t</span>		<span class="n">reserved2</span><span class="p">;</span>

			<span class="kt">uint8_t</span>		<span class="n">total_size</span><span class="p">;</span>
			<span class="kt">uint8_t</span>		<span class="n">access_size</span><span class="p">;</span>
		<span class="p">};</span>
		<span class="kt">uint32_t</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">rpmbs</span><span class="p">;</span>

	<span class="cm">/** extended device self-test time (in minutes) */</span>
	<span class="kt">uint16_t</span> <span class="n">edstt</span><span class="p">;</span>

	<span class="cm">/** device self-test options */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="cm">/** Device supports only one device self-test operation at a time */</span>
			<span class="kt">uint8_t</span> <span class="nl">one_only</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

			<span class="kt">uint8_t</span> <span class="nl">reserved</span>	<span class="p">:</span> <span class="mi">7</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">bits</span><span class="p">;</span>
		<span class="kt">uint8_t</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">dsto</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Firmware update granularity</span>
<span class="cm">	 *</span>
<span class="cm">	 * 4KB units</span>
<span class="cm">	 * 0x00 = no information provided</span>
<span class="cm">	 * 0xFF = no restriction</span>
<span class="cm">	 */</span>
	<span class="kt">uint8_t</span> <span class="n">fwug</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * Keep Alive Support</span>
<span class="cm">	 *</span>
<span class="cm">	 * Granularity of keep alive timer in 100 ms units</span>
<span class="cm">	 * 0 = keep alive not supported</span>
<span class="cm">	 */</span>
	<span class="kt">uint16_t</span> <span class="n">kas</span><span class="p">;</span>

	<span class="cm">/** Host controlled thermal management attributes */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint16_t</span>	<span class="nl">supported</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint16_t</span>	<span class="nl">reserved</span> <span class="p">:</span> <span class="mi">15</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">bits</span><span class="p">;</span>
		<span class="kt">uint16_t</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">hctma</span><span class="p">;</span>

	<span class="kt">uint16_t</span> <span class="n">mntmt</span><span class="p">;</span>	<span class="c1">///&lt; Minimum Thermal Management Temperature</span>
	<span class="kt">uint16_t</span> <span class="n">mxtmt</span><span class="p">;</span>	<span class="c1">///&lt; Maximum Thermal Management Temperature</span>

	<span class="cm">/** Sanitize capabilities */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint32_t</span> <span class="nl">crypto_erase</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="nl">block_erase</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="nl">overwrite</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="nl">reserved</span>	<span class="p">:</span> <span class="mi">29</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">bits</span><span class="p">;</span>
		<span class="kt">uint32_t</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">sanicap</span><span class="p">;</span>

	<span class="kt">uint8_t</span> <span class="n">reserved3</span><span class="p">[</span><span class="mi">180</span><span class="p">];</span>

	<span class="cm">/* bytes 512-703: nvm command set attributes */</span>

	<span class="cm">/** submission queue entry size */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint8_t</span>		<span class="nl">min</span> <span class="p">:</span> <span class="mi">4</span><span class="p">;</span>
			<span class="kt">uint8_t</span>		<span class="nl">max</span> <span class="p">:</span> <span class="mi">4</span><span class="p">;</span>
		<span class="p">};</span>
		<span class="kt">uint8_t</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">sqes</span><span class="p">;</span>

	<span class="cm">/** completion queue entry size */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint8_t</span>		<span class="nl">min</span> <span class="p">:</span> <span class="mi">4</span><span class="p">;</span>
			<span class="kt">uint8_t</span>		<span class="nl">max</span> <span class="p">:</span> <span class="mi">4</span><span class="p">;</span>
		<span class="p">};</span>
		<span class="kt">uint8_t</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">cqes</span><span class="p">;</span>

	<span class="kt">uint16_t</span> <span class="n">maxcmd</span><span class="p">;</span>

	<span class="kt">uint32_t</span> <span class="n">nn</span><span class="p">;</span>	<span class="c1">///&lt; Number of Namespaces</span>

	<span class="cm">/** optional nvm command support */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint16_t</span> <span class="nl">compare</span>		<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint16_t</span> <span class="nl">write_unc</span>		<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint16_t</span> <span class="nl">dsm</span>			<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint16_t</span> <span class="nl">write_zeroes</span>		<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint16_t</span> <span class="nl">set_features_save</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint16_t</span> <span class="nl">reservations</span>		<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint16_t</span> <span class="nl">timestamp</span>		<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint16_t</span> <span class="nl">reserved</span>		<span class="p">:</span> <span class="mi">9</span><span class="p">;</span>
		<span class="p">};</span>
		<span class="kt">uint16_t</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">oncs</span><span class="p">;</span>

	<span class="kt">uint16_t</span> <span class="n">fuses</span><span class="p">;</span> <span class="c1">///&lt; Fused Operation Support</span>

	<span class="cm">/** format nvm attributes */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint8_t</span> <span class="nl">format_all_ns</span>		<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint8_t</span> <span class="nl">erase_all_ns</span>		<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint8_t</span> <span class="nl">crypto_erase_supported</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint8_t</span> <span class="nl">reserved</span>		<span class="p">:</span> <span class="mi">5</span><span class="p">;</span>
		<span class="p">};</span>
		<span class="kt">uint8_t</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">fna</span><span class="p">;</span>

	<span class="cm">/** volatile write cache */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint8_t</span> <span class="nl">present</span>		<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint8_t</span> <span class="nl">flush_broadcast</span>	<span class="p">:</span> <span class="mi">2</span><span class="p">;</span>
			<span class="kt">uint8_t</span> <span class="nl">reserved</span>	<span class="p">:</span> <span class="mi">5</span><span class="p">;</span>
		<span class="p">};</span>
		<span class="kt">uint8_t</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">vwc</span><span class="p">;</span>

	<span class="kt">uint16_t</span> <span class="n">awun</span><span class="p">;</span>		<span class="c1">///&lt; Atomic Write Unit Normal</span>
	<span class="kt">uint16_t</span> <span class="n">awupf</span><span class="p">;</span>		<span class="c1">///&lt; Atomic Write Unit Power Fail</span>
	<span class="kt">uint8_t</span> <span class="n">nvscc</span><span class="p">;</span>		<span class="c1">///&lt; NVM vendor specific command configuration</span>

	<span class="kt">uint8_t</span> <span class="n">reserved531</span><span class="p">;</span>

	<span class="kt">uint16_t</span> <span class="n">acwu</span><span class="p">;</span>		<span class="c1">///&lt; atomic compare &amp; write unit</span>

	<span class="kt">uint16_t</span> <span class="n">reserved534</span><span class="p">;</span>

	<span class="cm">/** SGL support */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint32_t</span> <span class="nl">supported</span>		<span class="p">:</span> <span class="mi">2</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="nl">keyed_sgl</span>		<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="nl">reserved1</span>		<span class="p">:</span> <span class="mi">13</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="nl">bit_bucket_descriptor</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="nl">metadata_pointer</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="nl">oversized_sgl</span>		<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="nl">metadata_address</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="nl">sgl_offset</span>		<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="nl">transport_sgl</span>		<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="nl">reserved2</span>		<span class="p">:</span> <span class="mi">10</span><span class="p">;</span>
		<span class="p">};</span>
		<span class="kt">uint32_t</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">sgls</span><span class="p">;</span>

	<span class="kt">uint32_t</span> <span class="n">mnan</span><span class="p">;</span>		<span class="c1">///&lt; Maximum Number of Allowed Namespaces</span>

	<span class="kt">uint8_t</span> <span class="n">reserved4</span><span class="p">[</span><span class="mi">224</span><span class="p">];</span>

	<span class="kt">uint8_t</span> <span class="n">subnqn</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

	<span class="kt">uint8_t</span> <span class="n">reserved5</span><span class="p">[</span><span class="mi">768</span><span class="p">];</span>

	<span class="cm">/** NVMe over Fabrics-specific fields */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/** I/O queue command capsule supported size (16-byte units) */</span>
		<span class="kt">uint32_t</span> <span class="n">ioccsz</span><span class="p">;</span>

		<span class="cm">/** I/O queue response capsule supported size (16-byte units) */</span>
		<span class="kt">uint32_t</span> <span class="n">iorcsz</span><span class="p">;</span>

		<span class="cm">/** In-capsule data offset (16-byte units) */</span>
		<span class="kt">uint16_t</span> <span class="n">icdoff</span><span class="p">;</span>

		<span class="cm">/** Controller attributes */</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint8_t</span> <span class="nl">ctrlr_model</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint8_t</span> <span class="nl">reserved</span>	<span class="p">:</span> <span class="mi">7</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">ctrattr</span><span class="p">;</span>

		<span class="cm">/** Maximum SGL block descriptors (0 = no limit) */</span>
		<span class="kt">uint8_t</span> <span class="n">msdbd</span><span class="p">;</span>

		<span class="kt">uint8_t</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">244</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">nvmf_specific</span><span class="p">;</span>

	<span class="cm">/* bytes 2048-3071: power state descriptors */</span>
	<span class="k">struct</span> <span class="n">xnvme_spec_power_state</span> <span class="n">psd</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>

	<span class="cm">/* bytes 3072-4095: vendor specific */</span>
	<span class="kt">uint8_t</span> <span class="n">vs</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_spec_idfy_ctrlr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4096</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given :;xnvme_spec_idfy_ctrlr to the given output stream</span>
<span class="cm"> *</span>
<span class="cm"> * @param stream output stream used for printing</span>
<span class="cm"> * @param idfy pointer to structure to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="n">xnvme_spec_idfy_ctrl_fpr</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_spec_idfy_ctrlr</span> <span class="o">*</span><span class="n">idfy</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given :;xnvme_spec_idfy_ctrlr to stdout</span>
<span class="cm"> *</span>
<span class="cm"> * @param idfy pointer to structure to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_spec_idfy_ctrl_pr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_spec_idfy_ctrlr</span> <span class="o">*</span><span class="n">idfy</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Representation of I/O Command Set Vector</span>
<span class="cm"> *</span>
<span class="cm"> * See NVMe spec tbd, section xyz, for details</span>
<span class="cm"> *</span>
<span class="cm"> * @struct xnvme_spec_cs_vector</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_spec_cs_vector</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint64_t</span> <span class="nl">nvm</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint64_t</span> <span class="nl">rsvd1</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint64_t</span> <span class="nl">zns</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint64_t</span> <span class="nl">rsvd</span> <span class="p">:</span> <span class="mi">61</span><span class="p">;</span>
		<span class="p">};</span>
		<span class="kt">uint64_t</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_spec_cs_vector</span><span class="p">)</span> <span class="o">==</span> <span class="mi">8</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cp">#define XNVME_SPEC_IDFY_CS_IOCSC_LEN 512</span>

<span class="cm">/**</span>
<span class="cm"> * Representation of I/O Command Set data structure</span>
<span class="cm"> *</span>
<span class="cm"> * See NVMe spec tbd, section xyz, for details</span>
<span class="cm"> *</span>
<span class="cm"> * @struct xnvme_spec_idfy_cs</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_spec_idfy_cs</span> <span class="p">{</span>
	<span class="c1">// I/O Command Set Combinations</span>
	<span class="k">struct</span> <span class="n">xnvme_spec_cs_vector</span> <span class="n">iocsc</span><span class="p">[</span><span class="n">XNVME_SPEC_IDFY_CS_IOCSC_LEN</span><span class="p">];</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_spec_idfy_cs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4096</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="kt">int</span>
<span class="n">xnvme_spec_idfy_cs_fpr</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_spec_idfy_cs</span> <span class="o">*</span><span class="n">idfy</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="kt">int</span>
<span class="nf">xnvme_spec_idfy_cs_pr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">xnvme_spec_idfy_cs</span> <span class="o">*</span><span class="n">idfy</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * NVMe completion result accessor</span>
<span class="cm"> *</span>
<span class="cm"> * TODO: clarify</span>
<span class="cm"> *</span>
<span class="cm"> * @struct xnvme_spec_idfy</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_spec_idfy</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">xnvme_spec_idfy_ctrlr</span> <span class="n">ctrlr</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">xnvme_spec_idfy_ns</span> <span class="n">ns</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">xnvme_spec_idfy_cs</span> <span class="n">cs</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_spec_idfy</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4096</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * NVMe command opcodes</span>
<span class="cm"> *</span>
<span class="cm"> * @see specification Section xx, figure yy</span>
<span class="cm"> *</span>
<span class="cm"> * @enum xnvme_spec_opcodes</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">xnvme_spec_opcodes</span> <span class="p">{</span>
	<span class="n">XNVME_SPEC_OPC_IDFY</span> <span class="o">=</span> <span class="mh">0x06</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_OPC_IDFY</span>
	<span class="n">XNVME_SPEC_OPC_LOG</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_OPC_LOG</span>
	<span class="n">XNVME_SPEC_OPC_SFEAT</span> <span class="o">=</span> <span class="mh">0x09</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_OPC_SFEAT</span>
	<span class="n">XNVME_SPEC_OPC_GFEAT</span> <span class="o">=</span> <span class="mh">0x0A</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_OPC_GFEAT</span>

	<span class="n">XNVME_SPEC_OPC_WRITE</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_OPC_WRITE</span>
	<span class="n">XNVME_SPEC_OPC_READ</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_OPC_READ</span>

	<span class="n">XNVME_SPEC_OPC_FMT_NVM</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_OPC_FMT_NVM</span>
	<span class="n">XNVME_SPEC_OPC_SANITIZE</span> <span class="o">=</span> <span class="mh">0x84</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_OPC_SANITIZE</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * NVMe Feature Identifiers</span>
<span class="cm"> *</span>
<span class="cm"> * TODO: expand these</span>
<span class="cm"> *</span>
<span class="cm"> * @enum xnvme_spec_feat_id</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">xnvme_spec_feat_id</span> <span class="p">{</span>
	<span class="n">XNVME_SPEC_FEAT_ARBITRATION</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_FEAT_ARBITRATION</span>
	<span class="n">XNVME_SPEC_FEAT_PWR_MGMT</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_FEAT_PWR_MGMT</span>
	<span class="n">XNVME_SPEC_FEAT_LBA_RANGETYPE</span> <span class="o">=</span> <span class="mh">0x3</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_FEAT_LBA_RANGETYPE</span>
	<span class="n">XNVME_SPEC_FEAT_TEMP_THRESHOLD</span> <span class="o">=</span> <span class="mh">0x4</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_FEAT_TEMP_THRESHOLD</span>
	<span class="n">XNVME_SPEC_FEAT_ERROR_RECOVERY</span> <span class="o">=</span> <span class="mh">0x5</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_FEAT_ERROR_RECOVERY</span>
	<span class="n">XNVME_SPEC_FEAT_VWCACHE</span> <span class="o">=</span> <span class="mh">0x6</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_FEAT_VWCACHE</span>
	<span class="n">XNVME_SPEC_FEAT_NQUEUES</span> <span class="o">=</span> <span class="mh">0x7</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_FEAT_NQUEUES</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * @enum xnvme_spec_feat_sel</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">xnvme_spec_feat_sel</span> <span class="p">{</span>
	<span class="n">XNVME_SPEC_FEAT_SEL_CURRENT</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_FEAT_SEL_CURRENT</span>
	<span class="n">XNVME_SPEC_FEAT_SEL_DEFAULT</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_FEAT_SEL_DEFAULT</span>
	<span class="n">XNVME_SPEC_FEAT_SEL_SAVED</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_FEAT_SEL_SAVED</span>
	<span class="n">XNVME_SPEC_FEAT_SEL_SUPPORTED</span> <span class="o">=</span> <span class="mh">0x3</span> <span class="c1">///&lt; XNVME_SPEC_FEAT_SEL_SUPPORTED</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Encapsulation of NVMe/NVM features</span>
<span class="cm"> *</span>
<span class="cm"> * This structure is an accessor for Command Dword 11 of an Get Features Cmd.</span>
<span class="cm"> * and encapsulation of values provided to the `xnvme_cmd_gfeat`.</span>
<span class="cm"> *</span>
<span class="cm"> * @struct xnvme_spec_feat</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_spec_feat</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>

		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint32_t</span> <span class="nl">tmpth</span>	<span class="p">:</span> <span class="mi">16</span><span class="p">;</span>	<span class="c1">///&lt; Temperature threshold</span>
			<span class="kt">uint32_t</span> <span class="nl">tmpsel</span>	<span class="p">:</span> <span class="mi">4</span><span class="p">;</span>	<span class="c1">///&lt; Threshold Temp. Select</span>
			<span class="kt">uint32_t</span> <span class="nl">thsel</span>	<span class="p">:</span> <span class="mi">3</span><span class="p">;</span>	<span class="c1">///&lt; Threshold Type Select</span>
		<span class="p">}</span> <span class="n">temp_threshold</span><span class="p">;</span>

		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint32_t</span> <span class="nl">tler</span>  <span class="p">:</span> <span class="mi">16</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="nl">dulbe</span> <span class="p">:</span>  <span class="mi">1</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="nl">rsvd</span>  <span class="p">:</span> <span class="mi">15</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">error_recovery</span><span class="p">;</span>	<span class="c1">// Error recovery attributes</span>

		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint32_t</span> <span class="nl">nsqa</span>	<span class="p">:</span> <span class="mi">16</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="nl">ncqa</span>	<span class="p">:</span> <span class="mi">16</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">nqueues</span><span class="p">;</span>

		<span class="kt">uint32_t</span> <span class="n">val</span><span class="p">;</span>	<span class="c1">///&lt; For constructing feature without accessors</span>
	<span class="p">};</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_spec_feat</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given :;xnvme_spec_feat to the given output stream</span>
<span class="cm"> *</span>
<span class="cm"> * @param stream output stream used for printing</span>
<span class="cm"> * @param fid feature identifier</span>
<span class="cm"> * @param feat feature values</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="n">xnvme_spec_feat_fpr</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">fid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xnvme_spec_feat</span> <span class="n">feat</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given :;xnvme_spec_feat to the given output stream</span>
<span class="cm"> *</span>
<span class="cm"> * @param fid feature identifier</span>
<span class="cm"> * @param feat feature values</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_spec_feat_pr</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">fid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xnvme_spec_feat</span> <span class="n">feat</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cp">#define XNVME_SPEC_FEAT_ERROR_RECOVERY_DULBE(feat) (feat &amp; (1 &lt;&lt; 16))</span>
<span class="cp">#define XNVME_SPEC_FEAT_ERROR_RECOVERY_TLER(feat)  (feat &amp; 0xffff)</span>

<span class="cp">#define XNVME_SPEC_FEAT_MEDIA_FEEDBACK_HECC(feat)  (feat &amp; 0x1)</span>
<span class="cp">#define XNVME_SPEC_FEAT_MEDIA_FEEDBACK_VHECC(feat) (feat &amp; 0x2)</span>

<span class="cm">/**</span>
<span class="cm"> * Representation of DSM ranges as defined in NVM Express 1.3 Figure 207 Dataset</span>
<span class="cm"> * Management Range Definition Figure 207</span>
<span class="cm"> *</span>
<span class="cm"> * @struct xnvme_spec_dsm_range</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_spec_dsm_range</span> <span class="p">{</span>
	<span class="kt">uint32_t</span>	<span class="n">cattr</span><span class="p">;</span>	<span class="c1">///&lt; Context attributes</span>
	<span class="kt">uint32_t</span>	<span class="n">nlb</span><span class="p">;</span>	<span class="c1">///&lt; Length in logical blocks</span>
	<span class="kt">uint64_t</span>	<span class="n">slba</span><span class="p">;</span>	<span class="c1">///&lt; Starting LBA</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Enumeration of NVMe flags</span>
<span class="cm"> *</span>
<span class="cm"> * TODO: document</span>
<span class="cm"> * @enum xnvme_spec_flag</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">xnvme_spec_flag</span> <span class="p">{</span>
	<span class="c1">// Limited Retry (LR)</span>
	<span class="n">XNVME_SPEC_FLAG_LIMITED_RETRY</span>		<span class="o">=</span> <span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">,</span>

	<span class="c1">// Force Unit Access (FUA)</span>
	<span class="n">XNVME_SPEC_FLAG_FORCE_UNIT_ACCESS</span>	<span class="o">=</span> <span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">,</span>

	<span class="c1">// Protection Information Check (PRCK)</span>
	<span class="n">XNVME_SPEC_FLAG_PRINFO_PRCHK_REF</span>	<span class="o">=</span> <span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">,</span>
	<span class="n">XNVME_SPEC_FLAG_PRINFO_PRCHK_APP</span>	<span class="o">=</span> <span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">,</span>
	<span class="n">XNVME_SPEC_FLAG_PRINFO_PRCHK_GUARD</span>	<span class="o">=</span> <span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">,</span>

	<span class="c1">// Protection Information Action (PRACT)</span>
	<span class="n">XNVME_SPEC_FLAG_PRINFO_PRACT</span>		<span class="o">=</span> <span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * @enum xnvme_nvme_sgl_descriptor_type</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">xnvme_nvme_sgl_descriptor_type</span> <span class="p">{</span>
	<span class="n">XNVME_SPEC_SGL_DESCR_TYPE_DATA_BLOCK</span>		<span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_SGL_DESCR_TYPE_DATA_BLOCK</span>
	<span class="n">XNVME_SPEC_SGL_DESCR_TYPE_BIT_BUCKET</span>		<span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_SGL_DESCR_TYPE_BIT_BUCKET</span>
	<span class="n">XNVME_SPEC_SGL_DESCR_TYPE_SEGMENT</span>		<span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_SGL_DESCR_TYPE_SEGMENT</span>
	<span class="n">XNVME_SPEC_SGL_DESCR_TYPE_LAST_SEGMENT</span>		<span class="o">=</span> <span class="mh">0x3</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_SGL_DESCR_TYPE_LAST_SEGMENT</span>
	<span class="n">XNVME_SPEC_SGL_DESCR_TYPE_KEYED_DATA_BLOCK</span>	<span class="o">=</span> <span class="mh">0x4</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_SGL_DESCR_TYPE_KEYED_DATA_BLOCK</span>
	<span class="n">XNVME_SPEC_SGL_DESCR_TYPE_VENDOR_SPECIFIC</span>	<span class="o">=</span> <span class="mh">0xf</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_SGL_DESCR_TYPE_VENDOR_SPECIFIC</span>
<span class="p">};</span>


<span class="cm">/**</span>
<span class="cm"> * @enum xnvme_spec_sgl_descriptor_subtype</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">xnvme_spec_sgl_descriptor_subtype</span> <span class="p">{</span>
	<span class="n">XNVME_SPEC_SGL_DESCR_SUBTYPE_ADDRESS</span>	<span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_SGL_DESCR_SUBTYPE_ADDRESS</span>
	<span class="n">XNVME_SPEC_SGL_DESCR_SUBTYPE_OFFSET</span>	<span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span> <span class="c1">///&lt; XNVME_SPEC_SGL_DESCR_SUBTYPE_OFFSET</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * SGL descriptor</span>
<span class="cm"> *</span>
<span class="cm"> * @struct xnvme_spec_sgl_descriptor</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_spec_sgl_descriptor</span> <span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">;</span>				<span class="c1">///&lt; common field</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint64_t</span> <span class="nl">rsvd</span>    <span class="p">:</span> <span class="mi">56</span><span class="p">;</span>
			<span class="kt">uint64_t</span> <span class="nl">subtype</span> <span class="p">:</span>  <span class="mi">4</span><span class="p">;</span>	<span class="c1">///&lt; SGL subtype</span>
			<span class="kt">uint64_t</span> <span class="nl">type</span>    <span class="p">:</span>  <span class="mi">4</span><span class="p">;</span>	<span class="c1">///&lt; SGL type</span>
		<span class="p">}</span> <span class="n">generic</span><span class="p">;</span>

		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint64_t</span> <span class="nl">len</span>     <span class="p">:</span> <span class="mi">32</span><span class="p">;</span>	<span class="c1">///&lt; Length of entry</span>
			<span class="kt">uint64_t</span> <span class="nl">rsvd</span>    <span class="p">:</span> <span class="mi">24</span><span class="p">;</span>
			<span class="kt">uint64_t</span> <span class="nl">subtype</span> <span class="p">:</span>  <span class="mi">4</span><span class="p">;</span>	<span class="c1">///&lt; SGL subtype</span>
			<span class="kt">uint64_t</span> <span class="nl">type</span>    <span class="p">:</span>  <span class="mi">4</span><span class="p">;</span>	<span class="c1">///&lt; SGL type</span>
		<span class="p">}</span> <span class="n">unkeyed</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_spec_sgl_descriptor</span><span class="p">)</span> <span class="o">==</span> <span class="mi">16</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * PRP or SGL for Data Transfer field</span>
<span class="cm"> *</span>
<span class="cm"> * @enum xnvme_spec_psdt</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">xnvme_spec_psdt</span> <span class="p">{</span>
	<span class="n">XNVME_SPEC_PSDT_PRP</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>
	<span class="n">XNVME_SPEC_PSDT_SGL_MPTR_CONTIGUOUS</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
	<span class="n">XNVME_SPEC_PSDT_SGL_MPTR_SGL</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * NVMe Command Accessor for common use of the 64byte NVMe command</span>
<span class="cm"> *</span>
<span class="cm"> * @see Specification section 4.3, figure 2</span>
<span class="cm"> * @see Specification section 4.3, figure 3</span>
<span class="cm"> *</span>
<span class="cm"> * @struct xnvme_spec_cmd_common</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_spec_cmd_common</span> <span class="p">{</span>
	<span class="cm">/* cdw 00 */</span>
	<span class="kt">uint16_t</span> <span class="nl">opcode</span>	<span class="p">:</span>  <span class="mi">8</span><span class="p">;</span>		<span class="c1">///&lt; OPC: Command Opcode</span>
	<span class="kt">uint16_t</span> <span class="nl">fuse</span>	<span class="p">:</span>  <span class="mi">2</span><span class="p">;</span>		<span class="c1">///&lt; FUSE: Fused Operation</span>
	<span class="kt">uint16_t</span> <span class="nl">rsvd</span>	<span class="p">:</span>  <span class="mi">4</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="nl">psdt</span>	<span class="p">:</span>  <span class="mi">2</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">cid</span><span class="p">;</span>			<span class="c1">///&lt; CID: Command Identifier</span>

	<span class="cm">/* cdw 01 */</span>
	<span class="kt">uint32_t</span> <span class="n">nsid</span><span class="p">;</span>			<span class="c1">///&lt; NSID: Namespace identifier</span>

	<span class="kt">uint32_t</span> <span class="n">cdw02</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cdw03</span><span class="p">;</span>

	<span class="cm">/* cdw 04-05 */</span>
	<span class="kt">uint64_t</span> <span class="n">mptr</span><span class="p">;</span>			<span class="c1">///&lt; MPTR -- metadata pointer</span>

	<span class="cm">/* cdw 06-09: */</span>		<span class="c1">///&lt; DPTR -- data pointer</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint64_t</span> <span class="n">prp1</span><span class="p">;</span>		<span class="c1">///&lt; PRP entry 1</span>
			<span class="kt">uint64_t</span> <span class="n">prp2</span><span class="p">;</span>		<span class="c1">///&lt; PRP entry 2</span>
		<span class="p">}</span> <span class="n">prp</span><span class="p">;</span>

		<span class="k">struct</span> <span class="n">xnvme_spec_sgl_descriptor</span> <span class="n">sgl</span><span class="p">;</span> <span class="c1">///&lt; SGL</span>

		<span class="cm">/**</span>
<span class="cm">		 * Accessors used by the IOCTL of the Linux Kernel NVMe driver</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint64_t</span> <span class="n">data</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">metadata_len</span><span class="p">;</span>
			<span class="kt">uint32_t</span> <span class="n">data_len</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">lnx_ioctl</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">dptr</span><span class="p">;</span>

	<span class="cm">/* cdw 10 */</span>
	<span class="kt">uint32_t</span> <span class="n">ndt</span><span class="p">;</span>	<span class="c1">///&lt; NDT: Number of dwords in Data Transfer</span>

	<span class="cm">/* cdw 11 */</span>
	<span class="kt">uint32_t</span> <span class="n">ndm</span><span class="p">;</span>	<span class="c1">///&lt; NDM: Number of dwords in Meta Transfer</span>

	<span class="kt">uint32_t</span> <span class="n">cdw12</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cdw13</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cdw14</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cdw15</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_spec_cmd_common</span><span class="p">)</span> <span class="o">==</span> <span class="mi">64</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm">* NVMe Command Accessor for the Sanitize command</span>
<span class="cm">*</span>
<span class="cm">* @struct xnvme_spec_cmd_sanitize</span>
<span class="cm">*/</span>
<span class="k">struct</span> <span class="n">xnvme_spec_cmd_sanitize</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">cdw00_09</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>	<span class="c1">///&lt; Command dword 0 to 9</span>

	<span class="kt">uint32_t</span> <span class="nl">sanact</span>	<span class="p">:</span> <span class="mi">3</span><span class="p">;</span>	<span class="c1">///&lt; Sanitize Action</span>
	<span class="kt">uint32_t</span> <span class="nl">ause</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">///&lt; Allow unrestr. San. Exit</span>
	<span class="kt">uint32_t</span> <span class="nl">owpass</span>	<span class="p">:</span> <span class="mi">4</span><span class="p">;</span>	<span class="c1">///&lt; Overwrite Pass Count</span>
	<span class="kt">uint32_t</span> <span class="nl">oipbp</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">///&lt; Overwrite Invert</span>
	<span class="kt">uint32_t</span> <span class="nl">nodas</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">///&lt; NoDeallocate after Sanitize</span>
	<span class="kt">uint32_t</span> <span class="nl">rsvd</span>	<span class="p">:</span> <span class="mi">22</span><span class="p">;</span>

	<span class="kt">uint32_t</span> <span class="n">ovrpat</span><span class="p">;</span>	<span class="c1">///&lt; Overwrite Pattern</span>

	<span class="kt">uint32_t</span> <span class="n">cdw12_15</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>	<span class="c1">///&lt; Command dword 12 to 15</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_spec_cmd_sanitize</span><span class="p">)</span> <span class="o">==</span> <span class="mi">64</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm">* NVMe Command Accessor for the NVM-format command</span>
<span class="cm">*</span>
<span class="cm">* @struct xnvme_spec_cmd_format</span>
<span class="cm">*/</span>
<span class="k">struct</span> <span class="n">xnvme_spec_cmd_format</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">cdw00_09</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>		<span class="c1">///&lt; Command dword 0 to 9</span>

	<span class="kt">uint32_t</span> <span class="nl">lbaf</span>		<span class="p">:</span> <span class="mi">4</span><span class="p">;</span>	<span class="c1">///&lt; The format to use</span>
	<span class="kt">uint32_t</span> <span class="nl">mset</span>		<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">///&lt; Meta-data settings</span>
	<span class="kt">uint32_t</span> <span class="nl">pi</span>		<span class="p">:</span> <span class="mi">3</span><span class="p">;</span>	<span class="c1">///&lt; Protection Information</span>
	<span class="kt">uint32_t</span> <span class="nl">pil</span>		<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">///&lt; Protection Information Loc.</span>
	<span class="kt">uint32_t</span> <span class="nl">ses</span>		<span class="p">:</span> <span class="mi">3</span><span class="p">;</span>	<span class="c1">///&lt; Secure Erase Settings</span>
	<span class="kt">uint32_t</span> <span class="nl">zf</span>		<span class="p">:</span> <span class="mi">2</span><span class="p">;</span>	<span class="c1">///&lt; TBD: Zone Format</span>
	<span class="kt">uint32_t</span> <span class="nl">rsvd</span>		<span class="p">:</span> <span class="mi">18</span><span class="p">;</span>

	<span class="kt">uint32_t</span> <span class="n">cdw11_15</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>		<span class="c1">///&lt; Command dword 11 to 15</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_spec_cmd_format</span><span class="p">)</span> <span class="o">==</span> <span class="mi">64</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm">* NVMe Command Accessor for the get-features command</span>
<span class="cm">*</span>
<span class="cm">* @struct xnvme_spec_cmd_gfeat</span>
<span class="cm">*/</span>
<span class="k">struct</span> <span class="n">xnvme_spec_cmd_gfeat</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">cdw00_09</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>		<span class="c1">///&lt; Command dword 0 to 9</span>

	<span class="kt">uint32_t</span> <span class="nl">fid</span>		<span class="p">:</span> <span class="mi">8</span><span class="p">;</span>	<span class="c1">///&lt; Feature Identifier</span>
	<span class="kt">uint32_t</span> <span class="nl">sel</span>		<span class="p">:</span> <span class="mi">3</span><span class="p">;</span>	<span class="c1">///&lt; Select</span>
	<span class="kt">uint32_t</span> <span class="nl">rsvd10</span>		<span class="p">:</span> <span class="mi">21</span><span class="p">;</span>

	<span class="kt">uint32_t</span> <span class="n">cdw11_15</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>		<span class="c1">///&lt; Command dword 11 to 15</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_spec_cmd_gfeat</span><span class="p">)</span> <span class="o">==</span> <span class="mi">64</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * NVMe Command Accessor for the set-features command</span>
<span class="cm"> *</span>
<span class="cm"> * @struct xnvme_spec_cmd_sfeat</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_spec_cmd_sfeat</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">cdw00_09</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>		<span class="c1">///&lt; Command dword 0 to 9</span>

	<span class="kt">uint32_t</span> <span class="nl">fid</span>		<span class="p">:</span> <span class="mi">8</span><span class="p">;</span>	<span class="c1">///&lt; Feature Identifier</span>
	<span class="kt">uint32_t</span> <span class="nl">rsvd10</span>		<span class="p">:</span> <span class="mi">23</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="nl">save</span>		<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">///&lt; Save</span>

	<span class="k">struct</span> <span class="n">xnvme_spec_feat</span> <span class="n">feat</span><span class="p">;</span>	<span class="c1">///&lt; Feature</span>

	<span class="kt">uint32_t</span> <span class="n">cdw12_15</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>		<span class="c1">///&lt; Command dword 12 to 15</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_spec_cmd_sfeat</span><span class="p">)</span> <span class="o">==</span> <span class="mi">64</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * NVMe Command Accessor for the identify command</span>
<span class="cm"> *</span>
<span class="cm"> * @struct xnvme_spec_cmd_idfy</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_spec_cmd_idfy</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">cdw00_09</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>		<span class="c1">///&lt; Command dword 0 to 9</span>

	<span class="kt">uint32_t</span> <span class="nl">cns</span>		<span class="p">:</span> <span class="mi">8</span><span class="p">;</span>	<span class="c1">///&lt; Controller or Namespace Structure</span>
	<span class="kt">uint32_t</span> <span class="nl">rsvd1</span>		<span class="p">:</span> <span class="mi">8</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="nl">cntid</span>		<span class="p">:</span> <span class="mi">16</span><span class="p">;</span>	<span class="c1">///&lt; Controller Identifier</span>

	<span class="kt">uint32_t</span> <span class="nl">nvmsetid</span>	<span class="p">:</span> <span class="mi">16</span><span class="p">;</span>	<span class="c1">///&lt; NVM Set Identifier</span>
	<span class="kt">uint32_t</span> <span class="nl">rsvd2</span>		<span class="p">:</span> <span class="mi">8</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="nl">csi</span>		<span class="p">:</span> <span class="mi">8</span><span class="p">;</span>	<span class="c1">///&lt; Command Set Identifier</span>

	<span class="kt">uint32_t</span> <span class="n">cdw12_13</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>		<span class="c1">///&lt; Command dword 12 to 13</span>

	<span class="kt">uint32_t</span> <span class="nl">uuid</span>		<span class="p">:</span> <span class="mi">7</span><span class="p">;</span>	<span class="c1">///&lt; UUID index</span>
	<span class="kt">uint32_t</span> <span class="nl">rsvd3</span>		<span class="p">:</span> <span class="mi">25</span><span class="p">;</span>

	<span class="kt">uint32_t</span> <span class="n">cdw15</span><span class="p">;</span>			<span class="c1">///&lt; Command dword 15</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_spec_cmd_idfy</span><span class="p">)</span> <span class="o">==</span> <span class="mi">64</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * NVMe Command Accessor for the get-log-page command</span>
<span class="cm"> *</span>
<span class="cm"> * @struct xnvme_spec_cmd_log</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_spec_cmd_log</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">cdw00_09</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>	<span class="c1">///&lt; Command dword 0 to 9</span>

	<span class="kt">uint32_t</span> <span class="nl">lid</span>	<span class="p">:</span> <span class="mi">8</span><span class="p">;</span>	<span class="c1">///&lt; Log Page Identifier</span>
	<span class="kt">uint32_t</span> <span class="nl">lsp</span>	<span class="p">:</span> <span class="mi">4</span><span class="p">;</span>		<span class="c1">///&lt; Log Specific Field</span>
	<span class="kt">uint32_t</span> <span class="nl">rsvd10</span>	<span class="p">:</span> <span class="mi">3</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="nl">rae</span>	<span class="p">:</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">///&lt; Retain Async. Event</span>
	<span class="kt">uint32_t</span> <span class="nl">numdl</span>	<span class="p">:</span> <span class="mi">16</span><span class="p">;</span>	<span class="c1">///&lt; Nr. of DWORDS lower-bits</span>

	<span class="kt">uint32_t</span> <span class="nl">numdu</span>	<span class="p">:</span> <span class="mi">16</span><span class="p">;</span>	<span class="c1">///&lt; Nr. of DWORDS upper-bits</span>
	<span class="kt">uint32_t</span> <span class="nl">rsvd11</span>	<span class="p">:</span> <span class="mi">16</span><span class="p">;</span>

	<span class="kt">uint32_t</span> <span class="n">lpol</span><span class="p">;</span>		<span class="c1">///&lt; Log-page offset lower 32bits</span>
	<span class="kt">uint32_t</span> <span class="n">lpou</span><span class="p">;</span>		<span class="c1">///&lt; Log-page offset upper 32bits</span>

	<span class="kt">uint32_t</span> <span class="n">cdw14_15</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>		<span class="c1">///&lt; Command dword 14 to 15</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_spec_cmd_log</span><span class="p">)</span> <span class="o">==</span> <span class="mi">64</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * NVMe Command Accessors for the NVM Command Set</span>
<span class="cm"> *</span>
<span class="cm"> * @struct xnvme_spec_cmd_lblk</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_spec_cmd_lblk</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">cdw00_09</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>	<span class="c1">///&lt; Command dword 0 to 9</span>

	<span class="kt">uint64_t</span> <span class="n">slba</span><span class="p">;</span>		<span class="c1">///&lt; SLBA: Start Logical Block Address</span>

	<span class="kt">uint32_t</span> <span class="nl">nlb</span>	<span class="p">:</span> <span class="mi">16</span><span class="p">;</span>	<span class="c1">///&lt; NLB: Number of logical blocks</span>
	<span class="kt">uint32_t</span> <span class="nl">rsvd</span>	<span class="p">:</span>  <span class="mi">4</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="nl">dtype</span>	<span class="p">:</span>  <span class="mi">4</span><span class="p">;</span>	<span class="c1">///&lt; DT: Directive Type</span>
	<span class="kt">uint32_t</span> <span class="nl">prinfo</span>	<span class="p">:</span>  <span class="mi">4</span><span class="p">;</span>	<span class="c1">///&lt; PI: Protection Information Field</span>
	<span class="kt">uint32_t</span> <span class="nl">rsvd2</span>	<span class="p">:</span>  <span class="mi">2</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="nl">fua</span>	<span class="p">:</span>  <span class="mi">1</span><span class="p">;</span>	<span class="c1">///&lt; FUA: Force unit access</span>
	<span class="kt">uint32_t</span> <span class="nl">lr</span>	<span class="p">:</span>  <span class="mi">1</span><span class="p">;</span>	<span class="c1">///&lt; LR: Limited retry</span>

	<span class="kt">uint32_t</span> <span class="n">cdw13_15</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>	<span class="c1">///&lt; Command dword 13 to 15</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_spec_cmd_lblk</span><span class="p">)</span> <span class="o">==</span> <span class="mi">64</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * NVMe Command Accessors</span>
<span class="cm"> *</span>
<span class="cm"> * @struct xnvme_spec_cmd</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_spec_cmd</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">xnvme_spec_cmd_common</span> <span class="n">common</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">xnvme_spec_cmd_sanitize</span> <span class="n">sanitize</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">xnvme_spec_cmd_format</span> <span class="n">format</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">xnvme_spec_cmd_log</span> <span class="n">log</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">xnvme_spec_cmd_gfeat</span> <span class="n">gfeat</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">xnvme_spec_cmd_sfeat</span> <span class="n">sfeat</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">xnvme_spec_cmd_idfy</span> <span class="n">idfy</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">xnvme_spec_cmd_lblk</span> <span class="n">lblk</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">};</span>
<span class="n">XNVME_STATIC_ASSERT</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_spec_cmd</span><span class="p">)</span> <span class="o">==</span> <span class="mi">64</span><span class="p">,</span> <span class="s">&quot;Incorrect size&quot;</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given :;xnvme_spec_cmd to the given output stream</span>
<span class="cm"> *</span>
<span class="cm"> * @param stream output stream used for printing</span>
<span class="cm"> * @param cmd pointer to structure to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="n">xnvme_spec_cmd_fpr</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xnvme_spec_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Prints the given :;xnvme_spec_cmd to stdout</span>
<span class="cm"> *</span>
<span class="cm"> * @param cmd pointer to structure to print</span>
<span class="cm"> * @param opts printer options, see ::xnvme_pr</span>
<span class="cm"> * @return On success, the number of characters printed is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">xnvme_spec_cmd_pr</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_spec_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opts</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* __LIBXNVME_SPEC_H */</span><span class="cp"></span>
</pre></div>
</div>
</div>
<div class="section" id="libxnvme-util-h">
<h2>libxnvme_util.h<a class="headerlink" href="#libxnvme-util-h" title="Permalink to this headline">¶</a></h2>
<p>Utilities, such as wall-clock timers, debug-macros, and more.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * libxnvme_util: timers, string-formats, debug-printers and other utilities</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) Simon A. F. Lund &lt;simon.lund@samsung.com&gt;</span>
<span class="cm"> * Copyright (C) Klaus B. A. Jensen &lt;k.jensen@samsung.com&gt;</span>
<span class="cm"> * SPDX-License-Identifier: Apache-2.0</span>
<span class="cm"> *</span>
<span class="cm"> * @file libxnvme_util.h</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __LIBXNVME_UTIL_H</span>
<span class="cp">#define __LIBXNVME_UTIL_H</span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>

<span class="cp">#define XNVME_UNIVERSAL_SECT_SH 9</span>

<span class="cm">/**</span>
<span class="cm"> * Macro wrapping C11 static assert, currently experiencing issues with the</span>
<span class="cm"> * asserts on FreeBSD, so trying this...</span>
<span class="cm"> */</span>
<span class="cp">#ifdef static_assert</span>
<span class="cp">#define XNVME_STATIC_ASSERT(cond, msg) static_assert(cond, msg);</span>
<span class="cp">#else</span>
<span class="cp">#define XNVME_STATIC_ASSERT(cond, msg)</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * Macro to suppress warnings on unused arguments, thanks to stackoverflow.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef __GNUC__</span>
<span class="cp">#define XNVME_UNUSED(x) UNUSED_ ## x __attribute__((__unused__))</span>
<span class="cp">#else</span>
<span class="cp">#define XNVME_UNUSED(x) UNUSED_ ## x</span>
<span class="cp">#endif</span>

<span class="cp">#define XNVME_I64_FMT \</span>
<span class="cp">	&quot;%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c&quot;\</span>
<span class="cp">	&quot;%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c&quot;\</span>
<span class="cp">	&quot;%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c&quot;\</span>
<span class="cp">	&quot;%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c&quot;</span>

<span class="cp">#define XNVME_I64_TO_STR(val) \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 63) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 62) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 61) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 60) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 59) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 58) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 57) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 56) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 55) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 54) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 53) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 52) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 51) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 50) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 49) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 48) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 47) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 46) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 45) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 44) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 43) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 42) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 41) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 40) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 39) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 38) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 37) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 36) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 35) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 34) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 33) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 32) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 31) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 30) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 29) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 28) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 27) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 26) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 25) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 24) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 23) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 22) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 21) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 20) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 19) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 18) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 17) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 16) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 15) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 14) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 13) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 12) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 11) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 10) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 9) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 8) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 7) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 6) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 5) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 4) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 3) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 2) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 1) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 0) ? &#39;1&#39; : &#39;0&#39;)</span>

<span class="cp">#define XNVME_I32_FMT \</span>
<span class="cp">	&quot;%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c&quot; \</span>
<span class="cp">	&quot;%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c&quot;</span>

<span class="cp">#define XNVME_I32_TO_STR(val) \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 31) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 30) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 29) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 28) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 27) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 26) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 25) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 24) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 23) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 22) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 21) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 20) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 19) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 18) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 17) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 16) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 15) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 14) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 13) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 12) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 11) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 10) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 9) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 8) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 7) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 6) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 5) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 4) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 3) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 2) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 1) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 0) ? &#39;1&#39; : &#39;0&#39;)</span>

<span class="cp">#define XNVME_I16_FMT	&quot;%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c&quot;</span>

<span class="cp">#define XNVME_I16_TO_STR(val) \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 15) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 14) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 13) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 12) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 11) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 10) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 9) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 8) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 7) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 6) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 5) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 4) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 3) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 2) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 1) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 0) ? &#39;1&#39; : &#39;0&#39;)</span>

<span class="cp">#define XNVME_I8_FMT	&quot;%c%c%c%c%c%c%c%c&quot;</span>

<span class="cp">#define XNVME_I8_TO_STR(val) \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 7) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 6) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 5) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 4) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 3) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 2) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 1) ? &#39;1&#39; : &#39;0&#39;), \</span>
<span class="cp">	(val &amp; (1ULL &lt;&lt; 0) ? &#39;1&#39; : &#39;0&#39;)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint64_t</span>
<span class="nf">XNVME_ILOG2</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm">* Calculate the minimum of the given `x` and `y`</span>
<span class="cm">*</span>
<span class="cm">* @param x</span>
<span class="cm">* @param y</span>
<span class="cm">* @return The maximum of `x` and `y`</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">XNVME_MIN</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="o">?</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Calculate the maximum of the given `x` and `y`</span>
<span class="cm"> *</span>
<span class="cm"> * @param x</span>
<span class="cm"> * @param y</span>
<span class="cm"> * @return The maximum of `x` and `y`</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">XNVME_MAX</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="o">?</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint64_t</span>
<span class="nf">_xnvme_timer_clock_sample</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts</span><span class="p">;</span>

	<span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">+</span> <span class="n">ts</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">*</span> <span class="mf">1e9</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Encapsulation of a basic wall-clock timer, start/stop clock</span>
<span class="cm"> *</span>
<span class="cm"> * @struct xnvme_timer</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xnvme_timer</span> <span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">start</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">stop</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Start the given timer</span>
<span class="cm"> *</span>
<span class="cm"> * @param t</span>
<span class="cm"> * @return clock sample in nano seconds</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint64_t</span>
<span class="nf">xnvme_timer_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_timer</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">_xnvme_timer_clock_sample</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Stop the given timer</span>
<span class="cm"> *</span>
<span class="cm"> * @param t</span>
<span class="cm"> * @return clock sample in nano seconds</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint64_t</span>
<span class="nf">xnvme_timer_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_timer</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">stop</span> <span class="o">=</span> <span class="n">_xnvme_timer_clock_sample</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Get the elapsed time in seconds</span>
<span class="cm"> *</span>
<span class="cm"> * @param t</span>
<span class="cm"> * @return elapsed time in seconds as a floating point number</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">double</span>
<span class="nf">xnvme_timer_elapsed_secs</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_timer</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">stop</span> <span class="o">-</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="mf">1e9</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Get the elapsed time in seconds</span>
<span class="cm"> *</span>
<span class="cm"> * @param t</span>
<span class="cm"> * @return elapsed time in seconds as a floating point number</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">double</span>
<span class="nf">xnvme_timer_elapsed</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_timer</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">xnvme_timer_elapsed_secs</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Get the elapsed time in milliseconds</span>
<span class="cm"> *</span>
<span class="cm"> * @param t</span>
<span class="cm"> * @return elapsed time in milliseconds as a floating point number</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">double</span>
<span class="nf">xnvme_timer_elapsed_msecs</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_timer</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">stop</span> <span class="o">-</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="mf">1e6</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Get the elapsed time in microseconds</span>
<span class="cm"> *</span>
<span class="cm"> * @param t</span>
<span class="cm"> * @return elapsed time in microseconds as a floating point number</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">double</span>
<span class="nf">xnvme_timer_elapsed_usecs</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_timer</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">stop</span> <span class="o">-</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="mf">1e3</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Get the elapsed time in nanoseconds</span>
<span class="cm"> *</span>
<span class="cm"> * @param t</span>
<span class="cm"> * @return elapsed time in nanoseconds</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint64_t</span>
<span class="nf">xnvme_timer_elapsed_nsecs</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_timer</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">stop</span> <span class="o">-</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Print the elapsed time in seconds as a floating point number</span>
<span class="cm"> *</span>
<span class="cm"> * @param t</span>
<span class="cm"> * @param prefix</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">xnvme_timer_pr</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_timer</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prefix</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s: {elapsed: %lf}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">xnvme_timer_elapsed</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Print the elapsed time in seconds and the associated data rate in MB/s</span>
<span class="cm"> *</span>
<span class="cm"> * @param t</span>
<span class="cm"> * @param prefix</span>
<span class="cm"> * @param nbytes</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">xnvme_timer_bw_pr</span><span class="p">(</span><span class="k">struct</span> <span class="n">xnvme_timer</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prefix</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">double</span> <span class="n">secs</span> <span class="o">=</span> <span class="n">xnvme_timer_elapsed_secs</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="kt">double</span> <span class="n">mb</span> <span class="o">=</span> <span class="n">nbytes</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="mi">1048576</span><span class="p">;</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s: {elapsed: %.4f, mb: %.2f, mbsec: %.2f}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">prefix</span><span class="p">,</span> <span class="n">secs</span><span class="p">,</span> <span class="n">mb</span><span class="p">,</span> <span class="n">mb</span> <span class="o">/</span> <span class="n">secs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">xnvme_is_pow2</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#ifdef XNVME_DEBUG_ENABLED</span>

<span class="cp">#define XNVME_DEBUG_FCALL(x) x</span>

<span class="cp">#define __FILENAME__ strrchr(&quot;/&quot; __FILE__, &#39;/&#39;) + 1</span>

<span class="cp">#define XNVME_DEBUG(...) \</span>
<span class="cp">	fprintf(stderr, &quot;# DBG:%s:%s-%d: &quot; FIRST(__VA_ARGS__) &quot;\n&quot; , \</span>
<span class="cp">		__FILENAME__, __func__, __LINE__ REST(__VA_ARGS__)); \</span>
<span class="cp">	fflush(stderr);</span>

<span class="cp">#define FIRST(...) FIRST_HELPER(__VA_ARGS__, throwaway)</span>
<span class="cp">#define FIRST_HELPER(first, ...) first</span>

<span class="cp">#define REST(...) REST_HELPER(NUM(__VA_ARGS__), __VA_ARGS__)</span>
<span class="cp">#define REST_HELPER(qty, ...) REST_HELPER2(qty, __VA_ARGS__)</span>
<span class="cp">#define REST_HELPER2(qty, ...) REST_HELPER_##qty(__VA_ARGS__)</span>
<span class="cp">#define REST_HELPER_ONE(first)</span>
<span class="cp">#define REST_HELPER_TWOORMORE(first, ...) , __VA_ARGS__</span>
<span class="cp">#define NUM(...) \</span>
<span class="cp">	SELECT_10TH(__VA_ARGS__, TWOORMORE, TWOORMORE, TWOORMORE, TWOORMORE,\</span>
<span class="cp">		    TWOORMORE, TWOORMORE, TWOORMORE, TWOORMORE, ONE, throwaway)</span>
<span class="cp">#define SELECT_10TH(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, ...) a10</span>

<span class="cp">#else</span>
<span class="cp">#define XNVME_DEBUG(...)</span>
<span class="cp">#define XNVME_DEBUG_FCALL(x)</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* __LIBXNVME_UTIL_H */</span><span class="cp"></span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="lblk.html" class="btn btn-neutral float-right" title="lblk" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="xnvme.html" class="btn btn-neutral float-left" title="xnvme" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, xNVMe

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-159785887-1', 'auto');
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>